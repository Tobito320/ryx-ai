#!/usr/bin/env python3
"""
Ryx AI - Global Entry Point

Production-grade local agentic CLI.
Works from any directory - AI interprets all commands naturally.
"""
import sys
import os
from pathlib import Path
from typing import Dict

# Auto-detect project root (resolve symlinks first, then get parent)
PROJECT_ROOT = Path(__file__).resolve().parent

# Add project to path
sys.path.insert(0, str(PROJECT_ROOT))

# Set environment variable for other modules to use
os.environ['RYX_PROJECT_ROOT'] = str(PROJECT_ROOT)


def main():
    """Main entry point - AI interprets all commands"""
    args = sys.argv[1:]

    # Parse global options only (these are the only "hardcoded" flags for CLI UX)
    safety_mode = "normal"
    silent_mode = False
    remaining_args = []

    for arg in args:
        if arg.startswith('--safety='):
            safety_mode = arg.split('=')[1]
        elif arg == '--strict':
            safety_mode = 'strict'
        elif arg == '--loose':
            safety_mode = 'loose'
        elif arg == '--silent' or arg == '-s':
            silent_mode = True
        elif arg in ['--help', '-h']:
            show_help()
            return
        elif arg in ['--version', '-v']:
            print("Ryx AI v2.0.0 - Production-grade local agentic CLI")
            return
        else:
            remaining_args.append(arg)

    # No args = Start interactive session
    if not remaining_args:
        from core.session_loop import SessionLoop
        session = SessionLoop(safety_mode=safety_mode)
        session.run()
        return

    # Everything else: Let AI interpret the prompt
    prompt = " ".join(remaining_args)
    
    from core.ai_interpreter import interpret_command
    
    action = interpret_command(prompt)
    
    # Execute the AI-determined action
    execute_action(action, safety_mode, silent_mode)


def execute_action(action, safety_mode: str, silent_mode: bool):
    """Execute an AI-determined action"""
    action_type = action.action_type
    target = action.target
    
    if action_type == "start_service":
        _start_service(target or "ryxhub")
    
    elif action_type == "stop_service":
        _stop_service(target or "ryxhub")
    
    elif action_type == "service_status":
        _service_status(target)
    
    elif action_type == "self_heal":
        _run_self_healing(action.parameters.get("aggressive", False))
    
    elif action_type == "remember":
        _remember(target, action.parameters)
    
    elif action_type == "recall":
        _recall(target)
    
    elif action_type == "chat":
        if silent_mode:
            _handle_silent_prompt(action.original_prompt, safety_mode)
        else:
            from core.session_loop import SessionLoop
            session = SessionLoop(safety_mode=safety_mode)
            session._process_input(action.original_prompt)
    
    elif action_type in ["open_file", "find_file", "code_help", "search_web", "system_task"]:
        from core.session_loop import SessionLoop
        session = SessionLoop(safety_mode=safety_mode)
        session._process_input(action.original_prompt)
    
    elif action_type == "run_command":
        if action.parameters.get("confirm", True):
            confirm = input(f"Run command: {target}? [y/N] ")
            if confirm.lower() != 'y':
                print("Cancelled")
                return
        import subprocess
        subprocess.run(target, shell=True)
    
    else:
        from core.session_loop import SessionLoop
        session = SessionLoop(safety_mode=safety_mode)
        session._process_input(action.original_prompt)


def _start_service(service: str):
    """Start a service"""
    service = service.lower().replace(" ", "").replace("-", "").replace("_", "")
    
    if service in ["ryxhub", "hub", "webui", "webinterface", "frontend", "dashboard", "web"]:
        from core.service_manager import ServiceManager
        manager = ServiceManager()
        result = manager.start_ryxhub()
        if result['success']:
            print("‚úÖ Starting RyxHub...")
            for line in result.get('info', []):
                print(f"  ‚îú‚îÄ {line}")
            print("‚úÖ RyxHub is running")
        else:
            print(f"‚ùå Failed to start RyxHub: {result.get('error', 'Unknown error')}")
    
    elif service in ["session", "interactive", "cli", "terminal"]:
        from core.session_loop import SessionLoop
        session = SessionLoop()
        session.run()
    
    else:
        print(f"‚ùå Unknown service: {service}")
        print("Available: ryxhub, session")


def _stop_service(service: str):
    """Stop a service"""
    service = service.lower().replace(" ", "").replace("-", "").replace("_", "")
    
    if service in ["ryxhub", "hub", "webui", "webinterface", "frontend", "dashboard", "web"]:
        from core.service_manager import ServiceManager
        manager = ServiceManager()
        result = manager.stop_ryxhub()
        if result['success']:
            print("‚úÖ Stopped RyxHub")
        else:
            print(f"‚ùå Failed to stop RyxHub: {result.get('error', 'Unknown error')}")
    else:
        print(f"‚ùå Unknown service: {service}")


def _service_status(service: str = None):
    """Check service status"""
    from core.service_manager import ServiceManager
    manager = ServiceManager()
    status = manager.get_status()
    
    print("üîç Service Status:")
    for svc, info in status.items():
        state = "üü¢ Running" if info.get('running') else "üî¥ Stopped"
        print(f"  {svc}: {state}")
        if info.get('ports'):
            for port_info in info['ports']:
                print(f"    ‚îî‚îÄ {port_info}")


def _run_self_healing(aggressive: bool = False):
    """Run AI-driven self-healing"""
    print("üß† Running self-healing...")
    print()
    
    from core.self_healer import run_self_healing
    result = run_self_healing(aggressive=aggressive)
    
    for detail in result.details:
        print(detail)
    
    print()
    print(result.summary)


def _remember(content: str, parameters: Dict):
    """Store something in long-term memory"""
    from core.memory import get_memory
    
    memory = get_memory()
    memory_type = parameters.get("type", "fact")
    
    if memory_type == "preference" and "key" in parameters:
        memory.learn_preference(
            parameters["key"], 
            parameters.get("value", content),
            source="explicit"
        )
        print(f"‚úÖ Remembered preference: {parameters['key']} = {parameters.get('value', content)}")
    else:
        memory_id = memory.remember(content, memory_type=memory_type, importance=0.8)
        print(f"‚úÖ Remembered: {content[:50]}...")


def _recall(query: str):
    """Recall information from memory"""
    from core.memory import get_memory
    
    memory = get_memory()
    profile = memory.profile
    
    print("üß† What I know about you:")
    print()
    print(f"  Environment:")
    print(f"    ‚Ä¢ OS: {profile.os} ({profile.distro})")
    print(f"    ‚Ä¢ WM: {profile.wm}")
    print(f"    ‚Ä¢ Shell: {profile.shell}")
    print(f"    ‚Ä¢ Editor: {profile.editor}")
    print(f"    ‚Ä¢ Terminal: {profile.terminal}")
    print()
    print(f"  Preferences:")
    print(f"    ‚Ä¢ Response style: {profile.response_length}")
    print(f"    ‚Ä¢ Tone: {profile.tone}")
    print(f"    ‚Ä¢ Prefers action over explanation: {not profile.prefers_explanations}")
    print()
    
    memories = memory.recall(query, limit=5)
    if memories:
        print(f"  Related memories ({len(memories)}):")
        for m in memories:
            print(f"    ‚Ä¢ [{m.memory_type}] {m.content[:60]}...")
    else:
        print("  No specific memories found for this query.")


def _handle_silent_prompt(prompt: str, safety_mode: str):
    """Handle prompt in silent mode"""
    import io
    from contextlib import redirect_stdout
    from modes.cli_mode import CLIMode

    cli = CLIMode()

    captured = io.StringIO()
    with redirect_stdout(captured):
        try:
            cli.handle_prompt(prompt)
        except Exception:
            pass

    output = captured.getvalue()
    output_lines = []
    for line in output.split('\n'):
        if line.strip() and '[thinking' not in line and '[searching' not in line and '[cached]' not in line:
            if not line.startswith('\033[2m'):
                output_lines.append(line)

    for line in output_lines[:3]:
        print(line)


def show_help():
    """Show help message"""
    print("""
üü£ Ryx AI - Local Agentic CLI

USAGE:
    ryx                      Start interactive session
    ryx "prompt"             Run any command in natural language
    ryx -s "prompt"          Silent mode (max 3 lines output)

EXAMPLES (AI interprets all commands naturally):
    ryx "start ryxhub"                    # Start web interface
    ryx "can you please start the hub"    # Same thing, natural language
    ryx "fire up the dashboard"           # Same thing, different phrasing
    ryx "strat ryxub"                     # Works even with typos!
    ryx "stop the web interface"          # Stop services
    ryx "open hyprland config"            # Open files
    ryx "search for python tutorials"     # Web search
    ryx "what time is it"                 # General questions
    ryx "remember i prefer dark mode"     # Store preference
    ryx "what do you know about me"       # Recall memories
    ryx "fix your brain"                  # Self-heal cache

The AI understands:
    ‚Ä¢ Typos and misspellings
    ‚Ä¢ Natural language variations
    ‚Ä¢ Implicit intent from context
    ‚Ä¢ Service names (ryxhub, hub, dashboard, web ui, etc.)

SESSION COMMANDS (inside interactive mode):
    /help        Show help
    /status      Show current status
    /tier <name> Switch model tier
    /models      List available models
    /quit        Exit session

For more info: https://github.com/ryx-ai
""")


if __name__ == "__main__":
    main()
