From b4a1600a5ea68871e1626897368cf3cddbb0f4bd Mon Sep 17 00:00:00 2001
From: Tobito320 <ahmedhdplay12345@gmail.com>
Date: Thu, 11 Dec 2025 19:44:56 +0100
Subject: [PATCH 06/11] persist: encrypted sqlite + autosave

Implemented encrypted SQLite persistence for sessions:
- Crypto class: Argon2id key derivation + ChaCha20-Poly1305 encryption
- PersistenceManager: encrypted SQLite storage with WAL mode
- Database schema: workspaces, sessions, tabs tables with foreign keys
- Autosave: periodic save every 30 seconds + graceful exit save
- Restore: load all sessions on startup

Features:
- Master password support (optional, uses Argon2id for key derivation)
- Encrypted storage for sensitive data (currently metadata only)
- WAL mode for better concurrency
- Foreign key constraints for data integrity
- Timestamp tracking (created_at, updated_at)

Integration:
- BrowserWindow initializes PersistenceManager on startup
- Loads saved sessions automatically
- Saves on graceful exit
- Periodic autosave every 30 seconds

Security:
- Argon2id parameters: time=3, mem=64MB, parallelism=1
- ChaCha20-Poly1305 (XChaCha20 variant) for encryption
- Salt stored separately from database
- Key derived from master password + salt

Tests:
- Crypto key derivation and encrypt/decrypt tests
- PersistenceManager initialization and save/load tests
---
 ryxsurf-cpp/include/crypto.h                  |   61 +
 ryxsurf-cpp/include/persistence_manager.h     |   76 +
 ryxsurf-cpp/meson.build                       |    4 +
 ...minimal-GTK4-WebKit-app-keyboard-nav.patch |    2 +-
 ...build-instructions-and-development-p.patch |    2 +-
 ...e-data-model-structs-session-manager.patch | 2443 +++++++++++++++++
 ...004-perf-tab-unload-restore-snapshot.patch |  625 +++++
 ryxsurf-cpp/repo-tree.txt                     |   18 +
 ryxsurf-cpp/src/browser_window.cpp            |   32 +-
 ryxsurf-cpp/src/crypto.cpp                    |   99 +
 ryxsurf-cpp/src/main.cpp                      |   10 +
 ryxsurf-cpp/src/persistence_manager.cpp       |  400 +++
 ryxsurf-cpp/tests/test_persistence.cpp        |   91 +
 13 files changed, 3856 insertions(+), 7 deletions(-)
 create mode 100644 ryxsurf-cpp/include/crypto.h
 create mode 100644 ryxsurf-cpp/include/persistence_manager.h
 create mode 100644 ryxsurf-cpp/patches/0003-core-data-model-structs-session-manager.patch
 create mode 100644 ryxsurf-cpp/patches/0004-perf-tab-unload-restore-snapshot.patch
 create mode 100644 ryxsurf-cpp/src/crypto.cpp
 create mode 100644 ryxsurf-cpp/src/persistence_manager.cpp
 create mode 100644 ryxsurf-cpp/tests/test_persistence.cpp

diff --git a/ryxsurf-cpp/include/crypto.h b/ryxsurf-cpp/include/crypto.h
new file mode 100644
index 0000000..ce9f815
--- /dev/null
+++ b/ryxsurf-cpp/include/crypto.h
@@ -0,0 +1,61 @@
+#pragma once
+
+#include <string>
+#include <vector>
+#include <memory>
+#include <sodium.h>
+
+/**
+ * Crypto utilities for password-based encryption.
+ * 
+ * Uses Argon2id for key derivation and ChaCha20-Poly1305 for encryption.
+ */
+class Crypto {
+public:
+    // Argon2id parameters
+    static constexpr unsigned long long OPS_LIMIT = 3;
+    static constexpr size_t MEM_LIMIT = 64 * 1024 * 1024;  // 64 MB
+    static constexpr unsigned int SALT_SIZE = 16;
+    static constexpr unsigned int KEY_SIZE = crypto_aead_xchacha20poly1305_ietf_KEYBYTES;
+    static constexpr unsigned int NONCE_SIZE = crypto_aead_xchacha20poly1305_ietf_NONCEBYTES;
+    
+    /**
+     * Derive encryption key from password using Argon2id.
+     * 
+     * @param password User password
+     * @param salt Salt (16 bytes, will be generated if empty)
+     * @return Pair of (derived_key, salt)
+     */
+    static std::pair<std::vector<unsigned char>, std::vector<unsigned char>>
+    derive_key(const std::string& password, const std::vector<unsigned char>& salt = {});
+    
+    /**
+     * Encrypt data using ChaCha20-Poly1305.
+     * 
+     * @param plaintext Data to encrypt
+     * @param key Encryption key (32 bytes)
+     * @return Encrypted data (nonce + ciphertext + tag)
+     */
+    static std::vector<unsigned char>
+    encrypt(const std::vector<unsigned char>& plaintext, const std::vector<unsigned char>& key);
+    
+    /**
+     * Decrypt data using ChaCha20-Poly1305.
+     * 
+     * @param ciphertext Encrypted data (nonce + ciphertext + tag)
+     * @param key Decryption key (32 bytes)
+     * @return Decrypted data
+     */
+    static std::vector<unsigned char>
+    decrypt(const std::vector<unsigned char>& ciphertext, const std::vector<unsigned char>& key);
+    
+    /**
+     * Generate random bytes.
+     */
+    static std::vector<unsigned char> random_bytes(size_t size);
+    
+    /**
+     * Initialize libsodium (call once at startup).
+     */
+    static void init();
+};
diff --git a/ryxsurf-cpp/include/persistence_manager.h b/ryxsurf-cpp/include/persistence_manager.h
new file mode 100644
index 0000000..8bf1e09
--- /dev/null
+++ b/ryxsurf-cpp/include/persistence_manager.h
@@ -0,0 +1,76 @@
+#pragma once
+
+#include "session_manager.h"
+#include "crypto.h"
+#include <sqlite3.h>
+#include <string>
+#include <memory>
+#include <optional>
+
+/**
+ * PersistenceManager handles encrypted SQLite storage for sessions.
+ * 
+ * Ownership: PersistenceManager does not own SessionManager.
+ * Uses WAL mode for better concurrency.
+ */
+class PersistenceManager {
+public:
+    PersistenceManager(SessionManager* session_manager);
+    ~PersistenceManager();
+
+    // Non-copyable, movable
+    PersistenceManager(const PersistenceManager&) = delete;
+    PersistenceManager& operator=(const PersistenceManager&) = delete;
+    PersistenceManager(PersistenceManager&&) = default;
+    PersistenceManager& operator=(PersistenceManager&&) = default;
+
+    // Database operations
+    bool initialize(const std::string& master_password = "");
+    void close();
+    
+    // Save/load operations
+    bool save_all();
+    bool load_all();
+    
+    // Individual workspace/session/tab operations
+    bool save_workspace(Workspace* workspace);
+    bool load_workspace(const std::string& name, Workspace* workspace);
+    
+    // Autosave
+    void enable_autosave(int interval_seconds = 30);
+    void disable_autosave();
+    
+    // Configuration
+    void set_master_password(const std::string& password);
+    bool has_master_password() const { return !master_password_.empty(); }
+
+private:
+    SessionManager* session_manager_;
+    sqlite3* db_;
+    std::string db_path_;
+    std::string master_password_;
+    std::vector<unsigned char> encryption_key_;
+    std::vector<unsigned char> salt_;
+    bool autosave_enabled_;
+    int autosave_interval_;
+    guint autosave_timer_id_;
+    
+    // Make db_path_ accessible for tests
+    friend class PersistenceManagerTest;
+    
+    // Database schema
+    bool create_schema();
+    bool create_tables();
+    
+    // Encryption helpers
+    bool setup_encryption();
+    std::vector<unsigned char> encrypt_data(const std::string& data);
+    std::string decrypt_data(const std::vector<unsigned char>& encrypted);
+    
+    // SQL helpers
+    bool execute_sql(const std::string& sql);
+    std::string get_db_path() const;
+    
+    // Autosave callback
+    static gboolean autosave_callback(gpointer user_data);
+};
diff --git a/ryxsurf-cpp/meson.build b/ryxsurf-cpp/meson.build
index f93341f..05ed5c1 100644
--- a/ryxsurf-cpp/meson.build
+++ b/ryxsurf-cpp/meson.build
@@ -67,6 +67,8 @@ sources = files(
   'src/workspace.cpp',
   'src/snapshot_manager.cpp',
   'src/tab_unload_manager.cpp',
+  'src/crypto.cpp',
+  'src/persistence_manager.cpp',
 )
 
 # Executable
@@ -93,6 +95,8 @@ if get_option('tests')
     test_sources = files(
       'tests/test_tab.cpp',
       'tests/test_session_manager.cpp',
+      'tests/test_unload.cpp',
+      'tests/test_persistence.cpp',
     )
     test_exe = executable(
       'test_ryxsurf',
diff --git a/ryxsurf-cpp/patches/0001-poC-minimal-GTK4-WebKit-app-keyboard-nav.patch b/ryxsurf-cpp/patches/0001-poC-minimal-GTK4-WebKit-app-keyboard-nav.patch
index 415de22..bc128d4 100644
--- a/ryxsurf-cpp/patches/0001-poC-minimal-GTK4-WebKit-app-keyboard-nav.patch
+++ b/ryxsurf-cpp/patches/0001-poC-minimal-GTK4-WebKit-app-keyboard-nav.patch
@@ -1,7 +1,7 @@
 From 7d081eead96e42fd3150cd2d5a4686d15105243a Mon Sep 17 00:00:00 2001
 From: Tobito320 <ahmedhdplay12345@gmail.com>
 Date: Thu, 11 Dec 2025 19:39:06 +0100
-Subject: [PATCH 1/2] poC: minimal GTK4 WebKit app + keyboard nav
+Subject: [PATCH 1/4] poC: minimal GTK4 WebKit app + keyboard nav
 
 Implemented proof-of-concept minimal browser:
 - GTK4 window with tab bar, address bar, notebook
diff --git a/ryxsurf-cpp/patches/0002-docs-Add-README-build-instructions-and-development-p.patch b/ryxsurf-cpp/patches/0002-docs-Add-README-build-instructions-and-development-p.patch
index ad39271..b654a27 100644
--- a/ryxsurf-cpp/patches/0002-docs-Add-README-build-instructions-and-development-p.patch
+++ b/ryxsurf-cpp/patches/0002-docs-Add-README-build-instructions-and-development-p.patch
@@ -1,7 +1,7 @@
 From 4af38b99685a9e4e79cedfcb2284735f4eeca88a Mon Sep 17 00:00:00 2001
 From: Tobito320 <ahmedhdplay12345@gmail.com>
 Date: Thu, 11 Dec 2025 19:39:16 +0100
-Subject: [PATCH 2/2] docs: Add README, build instructions, and development
+Subject: [PATCH 2/4] docs: Add README, build instructions, and development
  plan
 
 ---
diff --git a/ryxsurf-cpp/patches/0003-core-data-model-structs-session-manager.patch b/ryxsurf-cpp/patches/0003-core-data-model-structs-session-manager.patch
new file mode 100644
index 0000000..b4ff8a6
--- /dev/null
+++ b/ryxsurf-cpp/patches/0003-core-data-model-structs-session-manager.patch
@@ -0,0 +1,2443 @@
+From 4d5913cef88acaf78ddb0434bf973fddc88cba6a Mon Sep 17 00:00:00 2001
+From: Tobito320 <ahmedhdplay12345@gmail.com>
+Date: Thu, 11 Dec 2025 19:42:09 +0100
+Subject: [PATCH 3/4] core: data model structs + session manager
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Implemented core data models:
+- Workspace class (named persistent container for sessions)
+- Session class (workspace subcontext containing tabs)
+- Enhanced Tab with unload/restore support
+- SessionManager with workspace/session/tab hierarchy
+
+Features:
+- Workspace → Session → Tab hierarchy
+- Overview placeholder session (persistent, cannot be deleted)
+- Auto-close empty sessions (except Overview)
+- Tab and session navigation
+- Timestamp tracking (created_at, updated_at)
+
+Updated BrowserWindow to use SessionManager:
+- All tab operations go through SessionManager
+- UI updates reflect current workspace/session/tab state
+- Proper integration with keyboard shortcuts
+
+Tests:
+- Unit tests for Workspace, Session, SessionManager
+- Test coverage for tab operations, session management, auto-close logic
+---
+ ryxsurf-cpp/include/browser_window.h          |    1 +
+ ryxsurf-cpp/include/session.h                 |   54 +
+ ryxsurf-cpp/include/session_manager.h         |   57 +
+ ryxsurf-cpp/include/workspace.h               |   50 +
+ ryxsurf-cpp/meson.build                       |    4 +
+ ...minimal-GTK4-WebKit-app-keyboard-nav.patch |    2 +-
+ ...build-instructions-and-development-p.patch | 1507 +++++++++++++++++
+ ryxsurf-cpp/src/browser_window.cpp            |  125 +-
+ ryxsurf-cpp/src/session.cpp                   |   69 +
+ ryxsurf-cpp/src/session_manager.cpp           |  159 ++
+ ryxsurf-cpp/src/workspace.cpp                 |   64 +
+ ryxsurf-cpp/tests/test_session_manager.cpp    |  103 ++
+ 12 files changed, 2140 insertions(+), 55 deletions(-)
+ create mode 100644 ryxsurf-cpp/include/session.h
+ create mode 100644 ryxsurf-cpp/include/session_manager.h
+ create mode 100644 ryxsurf-cpp/include/workspace.h
+ create mode 100644 ryxsurf-cpp/patches/0002-docs-Add-README-build-instructions-and-development-p.patch
+ create mode 100644 ryxsurf-cpp/src/session.cpp
+ create mode 100644 ryxsurf-cpp/src/session_manager.cpp
+ create mode 100644 ryxsurf-cpp/src/workspace.cpp
+ create mode 100644 ryxsurf-cpp/tests/test_session_manager.cpp
+
+diff --git a/ryxsurf-cpp/include/browser_window.h b/ryxsurf-cpp/include/browser_window.h
+index d9a78e2..283f28c 100644
+--- a/ryxsurf-cpp/include/browser_window.h
++++ b/ryxsurf-cpp/include/browser_window.h
+@@ -6,6 +6,7 @@
+ #include <memory>
+ #include "tab.h"
+ #include "keyboard_handler.h"
++#include "session_manager.h"
+ 
+ /**
+  * BrowserWindow is the main GTK4 window containing the browser UI.
+diff --git a/ryxsurf-cpp/include/session.h b/ryxsurf-cpp/include/session.h
+new file mode 100644
+index 0000000..5764040
+--- /dev/null
++++ b/ryxsurf-cpp/include/session.h
+@@ -0,0 +1,54 @@
++#pragma once
++
++#include "tab.h"
++#include <vector>
++#include <string>
++#include <memory>
++#include <chrono>
++
++/**
++ * Session represents a workspace subcontext containing multiple tabs.
++ * 
++ * Ownership: Session owns its Tab objects. Sessions may be empty
++ * (showing Overview placeholder) or contain real tabs.
++ */
++class Session {
++public:
++    Session(const std::string& name);
++    ~Session();
++
++    // Non-copyable, movable
++    Session(const Session&) = delete;
++    Session& operator=(const Session&) = delete;
++    Session(Session&&) = default;
++    Session& operator=(Session&&) = default;
++
++    // Tab management
++    Tab* add_tab(const std::string& url = "about:blank");
++    void remove_tab(size_t index);
++    Tab* get_tab(size_t index);
++    size_t get_tab_count() const { return tabs_.size(); }
++    
++    // Active tab
++    size_t get_active_tab_index() const { return active_tab_index_; }
++    void set_active_tab(size_t index);
++    Tab* get_active_tab();
++
++    // Session metadata
++    std::string get_name() const { return name_; }
++    bool is_empty() const { return tabs_.empty(); }
++    bool is_overview() const { return is_overview_; }
++    void set_overview(bool overview) { is_overview_ = overview; }
++    
++    std::chrono::system_clock::time_point get_created_at() const { return created_at_; }
++    std::chrono::system_clock::time_point get_updated_at() const { return updated_at_; }
++    void mark_updated();
++
++private:
++    std::string name_;
++    std::vector<std::unique_ptr<Tab>> tabs_;
++    size_t active_tab_index_;
++    bool is_overview_;
++    std::chrono::system_clock::time_point created_at_;
++    std::chrono::system_clock::time_point updated_at_;
++};
+diff --git a/ryxsurf-cpp/include/session_manager.h b/ryxsurf-cpp/include/session_manager.h
+new file mode 100644
+index 0000000..0fe52fc
+--- /dev/null
++++ b/ryxsurf-cpp/include/session_manager.h
+@@ -0,0 +1,57 @@
++#pragma once
++
++#include "workspace.h"
++#include <vector>
++#include <string>
++#include <memory>
++
++/**
++ * SessionManager manages workspaces and provides high-level session operations.
++ * 
++ * Ownership: SessionManager owns all Workspace objects. This is the root
++ * of the session hierarchy: Workspace -> Session -> Tab.
++ */
++class SessionManager {
++public:
++    SessionManager();
++    ~SessionManager();
++
++    // Non-copyable, movable
++    SessionManager(const SessionManager&) = delete;
++    SessionManager& operator=(const SessionManager&) = delete;
++    SessionManager(SessionManager&&) = default;
++    SessionManager& operator=(SessionManager&&) = default;
++
++    // Workspace management
++    Workspace* add_workspace(const std::string& name);
++    Workspace* get_workspace(size_t index);
++    size_t get_workspace_count() const { return workspaces_.size(); }
++    
++    // Current workspace/session/tab access
++    Workspace* get_current_workspace();
++    Session* get_current_session();
++    Tab* get_current_tab();
++    
++    // Navigation
++    void switch_workspace(size_t index);
++    void switch_session(size_t index);
++    void switch_tab(size_t index);
++    
++    // Tab operations
++    Tab* new_tab(const std::string& url = "about:blank");
++    void close_current_tab();
++    
++    // Tab navigation within current session
++    void next_tab();
++    void previous_tab();
++    
++    // Session navigation within current workspace
++    void next_session();
++    void previous_session();
++
++private:
++    std::vector<std::unique_ptr<Workspace>> workspaces_;
++    size_t current_workspace_index_;
++    
++    void ensure_default_workspace();
++};
+diff --git a/ryxsurf-cpp/include/workspace.h b/ryxsurf-cpp/include/workspace.h
+new file mode 100644
+index 0000000..d627362
+--- /dev/null
++++ b/ryxsurf-cpp/include/workspace.h
+@@ -0,0 +1,50 @@
++#pragma once
++
++#include <string>
++#include <vector>
++#include <memory>
++#include <chrono>
++
++class Session;  // Forward declaration
++
++/**
++ * Workspace represents a named persistent container for sessions.
++ * 
++ * Ownership: Workspace owns its Session objects.
++ * Workspaces persist across application restarts.
++ */
++class Workspace {
++public:
++    Workspace(const std::string& name);
++    ~Workspace();
++
++    // Non-copyable, movable
++    Workspace(const Workspace&) = delete;
++    Workspace& operator=(const Workspace&) = delete;
++    Workspace(Workspace&&) = default;
++    Workspace& operator=(Workspace&&) = default;
++
++    // Session management
++    Session* add_session(const std::string& name);
++    void remove_session(size_t index);
++    Session* get_session(size_t index);
++    size_t get_session_count() const { return sessions_.size(); }
++    
++    // Active session
++    size_t get_active_session_index() const { return active_session_index_; }
++    void set_active_session(size_t index);
++    Session* get_active_session();
++
++    // Workspace metadata
++    std::string get_name() const { return name_; }
++    std::chrono::system_clock::time_point get_created_at() const { return created_at_; }
++    std::chrono::system_clock::time_point get_updated_at() const { return updated_at_; }
++    void mark_updated();
++
++private:
++    std::string name_;
++    std::vector<std::unique_ptr<Session>> sessions_;
++    size_t active_session_index_;
++    std::chrono::system_clock::time_point created_at_;
++    std::chrono::system_clock::time_point updated_at_;
++};
+diff --git a/ryxsurf-cpp/meson.build b/ryxsurf-cpp/meson.build
+index acc3ebb..6ba2903 100644
+--- a/ryxsurf-cpp/meson.build
++++ b/ryxsurf-cpp/meson.build
+@@ -61,6 +61,9 @@ sources = files(
+   'src/browser_window.cpp',
+   'src/tab.cpp',
+   'src/keyboard_handler.cpp',
++  'src/session_manager.cpp',
++  'src/session.cpp',
++  'src/workspace.cpp',
+ )
+ 
+ # Executable
+@@ -85,6 +88,7 @@ if get_option('tests')
+   if catch2_dep.found()
+     test_sources = files(
+       'tests/test_tab.cpp',
++      'tests/test_session_manager.cpp',
+     )
+     test_exe = executable(
+       'test_ryxsurf',
+diff --git a/ryxsurf-cpp/patches/0001-poC-minimal-GTK4-WebKit-app-keyboard-nav.patch b/ryxsurf-cpp/patches/0001-poC-minimal-GTK4-WebKit-app-keyboard-nav.patch
+index 21466cc..415de22 100644
+--- a/ryxsurf-cpp/patches/0001-poC-minimal-GTK4-WebKit-app-keyboard-nav.patch
++++ b/ryxsurf-cpp/patches/0001-poC-minimal-GTK4-WebKit-app-keyboard-nav.patch
+@@ -1,7 +1,7 @@
+ From 7d081eead96e42fd3150cd2d5a4686d15105243a Mon Sep 17 00:00:00 2001
+ From: Tobito320 <ahmedhdplay12345@gmail.com>
+ Date: Thu, 11 Dec 2025 19:39:06 +0100
+-Subject: [PATCH] poC: minimal GTK4 WebKit app + keyboard nav
++Subject: [PATCH 1/2] poC: minimal GTK4 WebKit app + keyboard nav
+ 
+ Implemented proof-of-concept minimal browser:
+ - GTK4 window with tab bar, address bar, notebook
+diff --git a/ryxsurf-cpp/patches/0002-docs-Add-README-build-instructions-and-development-p.patch b/ryxsurf-cpp/patches/0002-docs-Add-README-build-instructions-and-development-p.patch
+new file mode 100644
+index 0000000..ad39271
+--- /dev/null
++++ b/ryxsurf-cpp/patches/0002-docs-Add-README-build-instructions-and-development-p.patch
+@@ -0,0 +1,1507 @@
++From 4af38b99685a9e4e79cedfcb2284735f4eeca88a Mon Sep 17 00:00:00 2001
++From: Tobito320 <ahmedhdplay12345@gmail.com>
++Date: Thu, 11 Dec 2025 19:39:16 +0100
++Subject: [PATCH 2/2] docs: Add README, build instructions, and development
++ plan
++
++---
++ ryxsurf-cpp/README.md                         |  121 ++
++ ryxsurf-cpp/build-instructions.md             |  139 +++
++ ...minimal-GTK4-WebKit-app-keyboard-nav.patch | 1004 +++++++++++++++++
++ ryxsurf-cpp/plan.md                           |  178 +++
++ ryxsurf-cpp/repo-tree.txt                     |   13 +
++ 5 files changed, 1455 insertions(+)
++ create mode 100644 ryxsurf-cpp/README.md
++ create mode 100644 ryxsurf-cpp/build-instructions.md
++ create mode 100644 ryxsurf-cpp/patches/0001-poC-minimal-GTK4-WebKit-app-keyboard-nav.patch
++ create mode 100644 ryxsurf-cpp/plan.md
++ create mode 100644 ryxsurf-cpp/repo-tree.txt
++
++diff --git a/ryxsurf-cpp/README.md b/ryxsurf-cpp/README.md
++new file mode 100644
++index 0000000..9f7cbda
++--- /dev/null
+++++ b/ryxsurf-cpp/README.md
++@@ -0,0 +1,121 @@
+++# RyxSurf C++
+++
+++Minimal, keyboard-first, resource-efficient desktop browser based on GTK4 + WebKit6.
+++
+++## Status: PoC Complete ✅
+++
+++Proof-of-concept implementation demonstrating:
+++- GTK4 window with minimal UI
+++- WebKit6 integration with lazy WebView loading
+++- Keyboard shortcuts (Ctrl+T, Ctrl+W, Ctrl+Arrow keys)
+++- Tab management with lazy instantiation
+++
+++## Build Instructions
+++
+++### Dependencies
+++
+++- GTK4 (>= 4.0)
+++- WebKitGTK6 (>= 2.40)
+++- SQLite3
+++- libsecret-1
+++- libsodium
+++- Meson (>= 0.60)
+++- Ninja
+++- C++17 compiler (GCC 8+ or Clang 8+)
+++
+++### Ubuntu/Debian
+++
+++```bash
+++sudo apt-get update
+++sudo apt-get install -y \
+++    build-essential \
+++    meson \
+++    ninja-build \
+++    libgtk-4-dev \
+++    libwebkitgtk-6.0-dev \
+++    libsqlite3-dev \
+++    libsecret-1-dev \
+++    libsodium-dev \
+++    pkg-config
+++```
+++
+++### Arch Linux
+++
+++```bash
+++sudo pacman -S \
+++    base-devel \
+++    meson \
+++    ninja \
+++    gtk4 \
+++    webkitgtk \
+++    sqlite \
+++    libsecret \
+++    libsodium \
+++    pkgconf
+++```
+++
+++### Build
+++
+++```bash
+++cd ryxsurf-cpp
+++meson setup build
+++meson compile -C build
+++```
+++
+++### Run
+++
+++```bash
+++./build/ryxsurf
+++```
+++
+++## Keyboard Shortcuts
+++
+++| Shortcut | Action |
+++|----------|--------|
+++| `Ctrl+T` | Open new tab |
+++| `Ctrl+W` | Close current tab |
+++| `Ctrl+↑` | Previous tab |
+++| `Ctrl+↓` | Next tab |
+++| `Ctrl+←` | Previous session (placeholder) |
+++| `Ctrl+→` | Next session (placeholder) |
+++| `Ctrl+Tab` | Next tab (fallback) |
+++| `Ctrl+Shift+Tab` | Previous tab (fallback) |
+++| `Ctrl+L` | Focus address bar |
+++| `Ctrl+Shift+S` | Save session snapshot (placeholder) |
+++
+++All shortcuts are handled globally at the application level for immediate, non-blocking response.
+++
+++## Architecture
+++
+++```
+++BrowserWindow (GTK4)
+++  ├─ Tab[] (lazy WebView loading)
+++  ├─ KeyboardHandler (global shortcuts)
+++  └─ UI Components (tab bar, address bar, notebook)
+++```
+++
+++### Lazy Loading
+++
+++Tabs are created with metadata only. WebKitWebView is instantiated only when:
+++1. Tab becomes active (focused)
+++2. User explicitly loads the tab
+++
+++Unloaded tabs maintain:
+++- URL
+++- Title
+++- Last active timestamp
+++
+++## Performance Targets
+++
+++- **Cold Start**: < 500ms (on modern NVMe desktop)
+++- **Idle RSS**: < 200MB (with 3 unloaded tabs + 1 loaded tab)
+++
+++See `perf/run_perf.sh` for performance testing.
+++
+++## Next Steps
+++
+++See `plan.md` for detailed development roadmap.
+++
+++## License
+++
+++MIT License
++diff --git a/ryxsurf-cpp/build-instructions.md b/ryxsurf-cpp/build-instructions.md
++new file mode 100644
++index 0000000..9a673b7
++--- /dev/null
+++++ b/ryxsurf-cpp/build-instructions.md
++@@ -0,0 +1,139 @@
+++# Build Instructions
+++
+++## Quick Start
+++
+++```bash
+++cd ryxsurf-cpp
+++meson setup build
+++meson compile -C build
+++./build/ryxsurf
+++```
+++
+++## Detailed Build Steps
+++
+++### 1. Install Dependencies
+++
+++#### Ubuntu 24.04 / Debian 12
+++
+++```bash
+++sudo apt-get update
+++sudo apt-get install -y \
+++    build-essential \
+++    meson \
+++    ninja-build \
+++    libgtk-4-dev \
+++    libwebkitgtk-6.0-dev \
+++    libsqlite3-dev \
+++    libsecret-1-dev \
+++    libsodium-dev \
+++    pkg-config
+++```
+++
+++#### Arch Linux
+++
+++```bash
+++sudo pacman -S \
+++    base-devel \
+++    meson \
+++    ninja \
+++    gtk4 \
+++    webkitgtk \
+++    sqlite \
+++    libsecret \
+++    libsodium \
+++    pkgconf
+++```
+++
+++### 2. Configure Build
+++
+++#### Release Build (Optimized)
+++
+++```bash
+++meson setup build --buildtype=release
+++```
+++
+++#### Debug Build
+++
+++```bash
+++meson setup build --buildtype=debug
+++```
+++
+++#### Debug with Sanitizers
+++
+++```bash
+++# Address sanitizer
+++meson setup build --buildtype=debug -Dsanitize=address
+++
+++# Thread sanitizer
+++meson setup build --buildtype=debug -Dsanitize=thread
+++
+++# Undefined behavior sanitizer
+++meson setup build --buildtype=debug -Dsanitize=undefined
+++```
+++
+++### 3. Compile
+++
+++```bash
+++meson compile -C build
+++```
+++
+++Or using ninja directly:
+++
+++```bash
+++cd build
+++ninja
+++```
+++
+++### 4. Run Tests
+++
+++```bash
+++meson test -C build
+++```
+++
+++### 5. Run Performance Tests
+++
+++```bash
+++./perf/run_perf.sh
+++```
+++
+++## Troubleshooting
+++
+++### Missing Dependencies
+++
+++If Meson reports missing dependencies:
+++
+++```bash
+++pkg-config --modversion gtk4
+++pkg-config --modversion webkitgtk-6.0
+++```
+++
+++### WebKitGTK Version
+++
+++Ensure WebKitGTK 6.0 (not 4.0) is installed:
+++
+++```bash
+++pkg-config --modversion webkitgtk-6.0
+++```
+++
+++Should show version >= 2.40.
+++
+++### Compiler Issues
+++
+++Ensure your compiler supports C++17:
+++
+++```bash
+++g++ --version  # Should be GCC 8+ or Clang 8+
+++```
+++
+++## Build Options
+++
+++Configure build options:
+++
+++```bash
+++meson configure build
+++```
+++
+++Available options:
+++- `buildtype`: release, debug, debugoptimized
+++- `sanitize`: none, address, thread, undefined
+++- `tests`: true/false (enable test build)
++diff --git a/ryxsurf-cpp/patches/0001-poC-minimal-GTK4-WebKit-app-keyboard-nav.patch b/ryxsurf-cpp/patches/0001-poC-minimal-GTK4-WebKit-app-keyboard-nav.patch
++new file mode 100644
++index 0000000..21466cc
++--- /dev/null
+++++ b/ryxsurf-cpp/patches/0001-poC-minimal-GTK4-WebKit-app-keyboard-nav.patch
++@@ -0,0 +1,1004 @@
+++From 7d081eead96e42fd3150cd2d5a4686d15105243a Mon Sep 17 00:00:00 2001
+++From: Tobito320 <ahmedhdplay12345@gmail.com>
+++Date: Thu, 11 Dec 2025 19:39:06 +0100
+++Subject: [PATCH] poC: minimal GTK4 WebKit app + keyboard nav
+++
+++Implemented proof-of-concept minimal browser:
+++- GTK4 window with tab bar, address bar, notebook
+++- WebKit6 integration with lazy WebView loading
+++- Keyboard shortcuts: Ctrl+T (new tab), Ctrl+W (close), Ctrl+Arrow keys (navigate)
+++- Tab management with lazy instantiation (WebView created only when focused)
+++- Basic UI updates and signal handling
+++- Meson build system configuration
+++- Unit tests skeleton (Catch2)
+++- Performance test script (measures cold start and RSS)
+++
+++This PoC demonstrates core architecture and keyboard-first navigation.
+++Session persistence, password manager, and other features are planned
+++for future milestones.
+++---
+++ ryxsurf-cpp/include/browser_window.h   |  62 ++++++
+++ ryxsurf-cpp/include/keyboard_handler.h |  31 +++
+++ ryxsurf-cpp/include/tab.h              |  57 ++++++
+++ ryxsurf-cpp/meson.build                |  98 +++++++++
+++ ryxsurf-cpp/meson_options.txt          |   2 +
+++ ryxsurf-cpp/perf/run_perf.sh           |  98 +++++++++
+++ ryxsurf-cpp/src/browser_window.cpp     | 265 +++++++++++++++++++++++++
+++ ryxsurf-cpp/src/keyboard_handler.cpp   |  90 +++++++++
+++ ryxsurf-cpp/src/main.cpp               |  22 ++
+++ ryxsurf-cpp/src/tab.cpp                | 119 +++++++++++
+++ ryxsurf-cpp/tests/test_tab.cpp         |  48 +++++
+++ 11 files changed, 892 insertions(+)
+++ create mode 100644 ryxsurf-cpp/include/browser_window.h
+++ create mode 100644 ryxsurf-cpp/include/keyboard_handler.h
+++ create mode 100644 ryxsurf-cpp/include/tab.h
+++ create mode 100644 ryxsurf-cpp/meson.build
+++ create mode 100644 ryxsurf-cpp/meson_options.txt
+++ create mode 100755 ryxsurf-cpp/perf/run_perf.sh
+++ create mode 100644 ryxsurf-cpp/src/browser_window.cpp
+++ create mode 100644 ryxsurf-cpp/src/keyboard_handler.cpp
+++ create mode 100644 ryxsurf-cpp/src/main.cpp
+++ create mode 100644 ryxsurf-cpp/src/tab.cpp
+++ create mode 100644 ryxsurf-cpp/tests/test_tab.cpp
+++
+++diff --git a/ryxsurf-cpp/include/browser_window.h b/ryxsurf-cpp/include/browser_window.h
+++new file mode 100644
+++index 0000000..d9a78e2
+++--- /dev/null
++++++ b/ryxsurf-cpp/include/browser_window.h
+++@@ -0,0 +1,62 @@
++++#pragma once
++++
++++#include <gtk/gtk.h>
++++#include <webkit/webkit.h>
++++#include <vector>
++++#include <memory>
++++#include "tab.h"
++++#include "keyboard_handler.h"
++++
++++/**
++++ * BrowserWindow is the main GTK4 window containing the browser UI.
++++ * 
++++ * Ownership: BrowserWindow owns Tab objects and KeyboardHandler.
++++ * The window manages the visual representation of tabs.
++++ */
++++class BrowserWindow {
++++public:
++++    BrowserWindow();
++++    ~BrowserWindow();
++++
++++    // Non-copyable, movable
++++    BrowserWindow(const BrowserWindow&) = delete;
++++    BrowserWindow& operator=(const BrowserWindow&) = delete;
++++    BrowserWindow(BrowserWindow&&) = default;
++++    BrowserWindow& operator=(BrowserWindow&&) = default;
++++
++++    void show();
++++    GtkWindow* get_window() { return window_; }
++++
++++    // Tab operations (called by KeyboardHandler)
++++    void new_tab(const std::string& url = "");
++++    void close_current_tab();
++++    void next_tab();
++++    void previous_tab();
++++    void focus_address_bar();
++++
++++private:
++++    GtkWindow* window_;
++++    GtkBox* main_box_;
++++    GtkBox* tab_bar_;
++++    GtkEntry* address_bar_;
++++    GtkNotebook* notebook_;
++++    
++++    std::vector<std::unique_ptr<Tab>> tabs_;
++++    size_t active_tab_index_;
++++    
++++    std::unique_ptr<KeyboardHandler> keyboard_handler_;
++++    
++++    // UI update methods
++++    void update_tab_bar();
++++    void update_address_bar();
++++    void update_notebook();
++++    void refresh_ui();
++++    
++++    // Signal handlers
++++    static void on_address_bar_activated(GtkEntry* entry, gpointer user_data);
++++    static void on_tab_close_clicked(GtkButton* button, gpointer user_data);
++++    
++++    // Tab webview management
++++    void ensure_tab_webview_loaded(Tab* tab);
++++    void show_tab(size_t index);
++++};
+++diff --git a/ryxsurf-cpp/include/keyboard_handler.h b/ryxsurf-cpp/include/keyboard_handler.h
+++new file mode 100644
+++index 0000000..9c7c013
+++--- /dev/null
++++++ b/ryxsurf-cpp/include/keyboard_handler.h
+++@@ -0,0 +1,31 @@
++++#pragma once
++++
++++#include <gtk/gtk.h>
++++#include <gdk/gdkkeysyms.h>
++++
++++class BrowserWindow;  // Forward declaration
++++
++++/**
++++ * KeyboardHandler manages global keyboard shortcuts for the browser.
++++ * 
++++ * All shortcuts are handled at the application level for immediate
++++ * non-blocking response.
++++ */
++++class KeyboardHandler {
++++public:
++++    KeyboardHandler(BrowserWindow* browser_window);
++++    ~KeyboardHandler();
++++
++++    // Setup keyboard shortcuts on a window
++++    void setup_shortcuts(GtkWindow* window);
++++
++++private:
++++    BrowserWindow* browser_window_;
++++    
++++    // Shortcut handlers
++++    static gboolean on_key_pressed(GtkEventControllerKey* controller,
++++                                   guint keyval,
++++                                   guint keycode,
++++                                   GdkModifierType state,
++++                                   gpointer user_data);
++++};
+++diff --git a/ryxsurf-cpp/include/tab.h b/ryxsurf-cpp/include/tab.h
+++new file mode 100644
+++index 0000000..27fec0f
+++--- /dev/null
++++++ b/ryxsurf-cpp/include/tab.h
+++@@ -0,0 +1,57 @@
++++#pragma once
++++
++++#include <webkit/webkit.h>
++++#include <gtk/gtk.h>
++++#include <string>
++++#include <memory>
++++#include <chrono>
++++
++++/**
++++ * Tab represents a single browser tab with lazy WebView loading.
++++ * 
++++ * Ownership: Tab owns its WebKitWebView when loaded, but the view
++++ * is managed by GTK container hierarchy. Tab metadata persists even
++++ * when webview is unloaded.
++++ */
++++class Tab {
++++public:
++++    Tab(const std::string& url = "about:blank");
++++    ~Tab();
++++
++++    // Non-copyable, movable
++++    Tab(const Tab&) = delete;
++++    Tab& operator=(const Tab&) = delete;
++++    Tab(Tab&&) = default;
++++    Tab& operator=(Tab&&) = default;
++++
++++    // WebView management
++++    WebKitWebView* get_webview();
++++    GtkWidget* get_container();
++++    void create_webview();
++++    void destroy_webview();
++++    bool is_loaded() const { return webview_ != nullptr; }
++++    bool is_unloaded() const { return is_unloaded_; }
++++
++++    // Metadata
++++    std::string get_url() const { return url_; }
++++    std::string get_title() const { return title_; }
++++    void set_url(const std::string& url) { url_ = url; }
++++    void set_title(const std::string& title) { title_ = title; }
++++    
++++    // Activity tracking
++++    void mark_active();
++++    std::chrono::steady_clock::time_point get_last_active() const { return last_active_; }
++++
++++    // Unload/restore
++++    void unload();
++++    void restore();
++++
++++private:
++++    std::string url_;
++++    std::string title_;
++++    WebKitWebView* webview_;
++++    GtkWidget* container_;
++++    std::chrono::steady_clock::time_point last_active_;
++++    bool is_unloaded_;
++++    std::string snapshot_path_;
++++};
+++diff --git a/ryxsurf-cpp/meson.build b/ryxsurf-cpp/meson.build
+++new file mode 100644
+++index 0000000..acc3ebb
+++--- /dev/null
++++++ b/ryxsurf-cpp/meson.build
+++@@ -0,0 +1,98 @@
++++project(
++++  'ryxsurf-cpp',
++++  'cpp',
++++  version: '0.1.0',
++++  license: 'MIT',
++++  default_options: [
++++    'cpp_std=c++17',
++++    'warning_level=3',
++++    'werror=false',
++++    'optimization=3',
++++    'b_lto=true',
++++  ],
++++)
++++
++++# Dependencies
++++gtk4_dep = dependency('gtk4', version: '>=4.0')
++++webkitgtk_dep = dependency('webkitgtk-6.0', version: '>=2.40')
++++sqlite3_dep = dependency('sqlite3')
++++libsecret_dep = dependency('libsecret-1')
++++libsodium_dep = dependency('libsodium')
++++
++++# Compiler flags
++++cpp = meson.get_compiler('cpp')
++++cpp_args = []
++++
++++# Release flags
++++if get_option('buildtype') == 'release'
++++  cpp_args += [
++++    '-O3',
++++    '-march=native',
++++    '-DNDEBUG',
++++    '-flto',
++++  ]
++++endif
++++
++++# Debug flags
++++if get_option('buildtype') == 'debug'
++++  cpp_args += [
++++    '-g',
++++    '-O0',
++++  ]
++++endif
++++
++++# Sanitizers (optional)
++++if get_option('sanitize') != 'none'
++++  if get_option('sanitize') == 'address'
++++    cpp_args += ['-fsanitize=address', '-fno-omit-frame-pointer']
++++  elif get_option('sanitize') == 'thread'
++++    cpp_args += ['-fsanitize=thread']
++++  elif get_option('sanitize') == 'undefined'
++++    cpp_args += ['-fsanitize=undefined']
++++  endif
++++endif
++++
++++# Include directories
++++inc_dir = include_directories('include')
++++
++++# Source files
++++sources = files(
++++  'src/main.cpp',
++++  'src/browser_window.cpp',
++++  'src/tab.cpp',
++++  'src/keyboard_handler.cpp',
++++)
++++
++++# Executable
++++executable(
++++  'ryxsurf',
++++  sources,
++++  include_directories: inc_dir,
++++  dependencies: [
++++    gtk4_dep,
++++    webkitgtk_dep,
++++    sqlite3_dep,
++++    libsecret_dep,
++++    libsodium_dep,
++++  ],
++++  cpp_args: cpp_args,
++++  install: true,
++++)
++++
++++# Tests
++++if get_option('tests')
++++  catch2_dep = dependency('catch2', required: false)
++++  if catch2_dep.found()
++++    test_sources = files(
++++      'tests/test_tab.cpp',
++++    )
++++    test_exe = executable(
++++      'test_ryxsurf',
++++      test_sources,
++++      include_directories: inc_dir,
++++      dependencies: [catch2_dep],
++++      cpp_args: cpp_args,
++++    )
++++    test('Tab Tests', test_exe)
++++  endif
++++endif
+++diff --git a/ryxsurf-cpp/meson_options.txt b/ryxsurf-cpp/meson_options.txt
+++new file mode 100644
+++index 0000000..421cbff
+++--- /dev/null
++++++ b/ryxsurf-cpp/meson_options.txt
+++@@ -0,0 +1,2 @@
++++option('tests', type: 'boolean', value: true, description: 'Build tests')
++++option('sanitize', type: 'combo', choices: ['none', 'address', 'thread', 'undefined'], value: 'none', description: 'Enable sanitizers')
+++diff --git a/ryxsurf-cpp/perf/run_perf.sh b/ryxsurf-cpp/perf/run_perf.sh
+++new file mode 100755
+++index 0000000..ed2f944
+++--- /dev/null
++++++ b/ryxsurf-cpp/perf/run_perf.sh
+++@@ -0,0 +1,98 @@
++++#!/bin/bash
++++# Performance testing script for ryxsurf-cpp
++++# Measures cold start time and memory usage
++++
++++set -e
++++
++++SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
++++PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
++++BUILD_DIR="$PROJECT_ROOT/build"
++++BINARY="$BUILD_DIR/ryxsurf"
++++
++++# Colors
++++RED='\033[0;31m'
++++GREEN='\033[0;32m'
++++YELLOW='\033[1;33m'
++++NC='\033[0m'
++++
++++# Check if binary exists
++++if [ ! -f "$BINARY" ]; then
++++    echo -e "${RED}Error: Binary not found at $BINARY${NC}"
++++    echo "Please build the project first: meson setup build && meson compile -C build"
++++    exit 1
++++fi
++++
++++# Create results directory
++++RESULTS_DIR="$PROJECT_ROOT/perf/results"
++++mkdir -p "$RESULTS_DIR"
++++TIMESTAMP=$(date +%Y%m%d_%H%M%S)
++++RESULT_FILE="$RESULTS_DIR/perf_${TIMESTAMP}.txt"
++++
++++echo "=== RyxSurf C++ Performance Test ===" | tee "$RESULT_FILE"
++++echo "Timestamp: $(date)" | tee -a "$RESULT_FILE"
++++echo "System: $(uname -a)" | tee -a "$RESULT_FILE"
++++echo "CPU: $(lscpu | grep 'Model name' | cut -d: -f2 | xargs)" | tee -a "$RESULT_FILE"
++++echo "Memory: $(free -h | grep '^Mem:' | awk '{print $2}')" | tee -a "$RESULT_FILE"
++++echo "" | tee -a "$RESULT_FILE"
++++
++++# Test 1: Cold Start Time
++++echo -e "${YELLOW}Test 1: Cold Start Time${NC}" | tee -a "$RESULT_FILE"
++++echo "Measuring time to first window display..." | tee -a "$RESULT_FILE"
++++
++++START_TIME=$(date +%s%N)
++++timeout 5s "$BINARY" 2>&1 > /dev/null &
++++BROWSER_PID=$!
++++
++++# Wait briefly for window
++++sleep 0.5
++++kill $BROWSER_PID 2>/dev/null || true
++++wait $BROWSER_PID 2>/dev/null || true
++++
++++END_TIME=$(date +%s%N)
++++ELAPSED_MS=$(( (END_TIME - START_TIME) / 1000000 ))
++++
++++echo "COLD_START_MS=${ELAPSED_MS}" | tee -a "$RESULT_FILE"
++++echo "Cold start time: ${ELAPSED_MS}ms" | tee -a "$RESULT_FILE"
++++echo "Target: < 500ms" | tee -a "$RESULT_FILE"
++++
++++if [ $ELAPSED_MS -lt 500 ]; then
++++    echo -e "${GREEN}✓ PASS${NC}" | tee -a "$RESULT_FILE"
++++else
++++    echo -e "${RED}✗ FAIL (exceeds target)${NC}" | tee -a "$RESULT_FILE"
++++fi
++++echo "" | tee -a "$RESULT_FILE"
++++
++++# Test 2: Memory Usage (Idle)
++++echo -e "${YELLOW}Test 2: Idle Memory Usage${NC}" | tee -a "$RESULT_FILE"
++++echo "Measuring RSS with 1 loaded tab..." | tee -a "$RESULT_FILE"
++++
++++"$BINARY" &
++++BROWSER_PID=$!
++++sleep 2
++++
++++# Get RSS (Resident Set Size) in KB
++++RSS_KB=$(ps -o rss= -p $BROWSER_PID 2>/dev/null || echo "0")
++++RSS_MB=$((RSS_KB / 1024))
++++
++++kill $BROWSER_PID 2>/dev/null || true
++++wait $BROWSER_PID 2>/dev/null || true
++++
++++echo "IDLE_RSS_MB=${RSS_MB}" | tee -a "$RESULT_FILE"
++++echo "Idle RSS: ${RSS_MB}MB" | tee -a "$RESULT_FILE"
++++echo "Target: < 200MB (with 3 unloaded + 1 loaded tab)" | tee -a "$RESULT_FILE"
++++
++++if [ $RSS_MB -lt 200 ]; then
++++    echo -e "${GREEN}✓ PASS${NC}" | tee -a "$RESULT_FILE"
++++else
++++    echo -e "${RED}✗ FAIL (exceeds target)${NC}" | tee -a "$RESULT_FILE"
++++fi
++++echo "" | tee -a "$RESULT_FILE"
++++
++++# Summary
++++echo "=== Summary ===" | tee -a "$RESULT_FILE"
++++echo "COLD_START_MS=${ELAPSED_MS}" | tee -a "$RESULT_FILE"
++++echo "IDLE_RSS_MB=${RSS_MB}" | tee -a "$RESULT_FILE"
++++echo "Results saved to: $RESULT_FILE" | tee -a "$RESULT_FILE"
++++
++++# Display results
++++cat "$RESULT_FILE"
+++diff --git a/ryxsurf-cpp/src/browser_window.cpp b/ryxsurf-cpp/src/browser_window.cpp
+++new file mode 100644
+++index 0000000..cbf9d6f
+++--- /dev/null
++++++ b/ryxsurf-cpp/src/browser_window.cpp
+++@@ -0,0 +1,265 @@
++++#include "browser_window.h"
++++#include <gtk/gtk.h>
++++#include <webkit/webkit.h>
++++#include <iostream>
++++
++++BrowserWindow::BrowserWindow()
++++    : window_(nullptr)
++++    , main_box_(nullptr)
++++    , tab_bar_(nullptr)
++++    , address_bar_(nullptr)
++++    , notebook_(nullptr)
++++    , active_tab_index_(0)
++++    , keyboard_handler_(std::make_unique<KeyboardHandler>(this))
++++{
++++    // Create main window
++++    window_ = GTK_WINDOW(gtk_window_new());
++++    gtk_window_set_title(window_, "RyxSurf");
++++    gtk_window_set_default_size(window_, 1200, 800);
++++    
++++    // Main vertical box
++++    main_box_ = GTK_BOX(gtk_box_new(GTK_ORIENTATION_VERTICAL, 0));
++++    gtk_window_set_child(window_, GTK_WIDGET(main_box_));
++++    
++++    // Tab bar (horizontal, compact)
++++    tab_bar_ = GTK_BOX(gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 4));
++++    gtk_widget_add_css_class(GTK_WIDGET(tab_bar_), "tab-bar");
++++    gtk_box_append(main_box_, GTK_WIDGET(tab_bar_));
++++    
++++    // Address bar
++++    address_bar_ = GTK_ENTRY(gtk_entry_new());
++++    gtk_entry_set_placeholder_text(address_bar_, "Enter URL or search...");
++++    g_signal_connect(address_bar_, "activate",
++++                     G_CALLBACK(on_address_bar_activated), this);
++++    gtk_box_append(main_box_, GTK_WIDGET(address_bar_));
++++    
++++    // Notebook for tab webviews
++++    notebook_ = GTK_NOTEBOOK(gtk_notebook_new());
++++    gtk_notebook_set_show_tabs(notebook_, FALSE);
++++    gtk_box_append(main_box_, GTK_WIDGET(notebook_));
++++    
++++    // Setup keyboard shortcuts
++++    keyboard_handler_->setup_shortcuts(window_);
++++    
++++    // Create initial tab
++++    new_tab();
++++    
++++    // Connect window close
++++    g_signal_connect(window_, "close-request",
++++                     G_CALLBACK(+[](GtkWindow* window, gpointer) -> gboolean {
++++                         gtk_window_destroy(window);
++++                         return TRUE;
++++                     }), nullptr);
++++}
++++
++++BrowserWindow::~BrowserWindow() {
++++    if (window_) {
++++        gtk_window_destroy(window_);
++++    }
++++}
++++
++++void BrowserWindow::show() {
++++    gtk_window_present(window_);
++++}
++++
++++void BrowserWindow::new_tab(const std::string& url) {
++++    auto tab = std::make_unique<Tab>(url.empty() ? "about:blank" : url);
++++    Tab* tab_ptr = tab.get();
++++    tabs_.push_back(std::move(tab));
++++    active_tab_index_ = tabs_.size() - 1;
++++    
++++    refresh_ui();
++++    show_tab(active_tab_index_);
++++    
++++    // Load URL if provided
++++    if (!url.empty()) {
++++        ensure_tab_webview_loaded(tab_ptr);
++++        webkit_web_view_load_uri(tab_ptr->get_webview(), url.c_str());
++++    }
++++}
++++
++++void BrowserWindow::close_current_tab() {
++++    if (tabs_.empty()) {
++++        return;
++++    }
++++    
++++    if (tabs_.size() == 1) {
++++        // Keep at least one tab
++++        Tab* tab = tabs_[0].get();
++++        tab->set_url("about:blank");
++++        ensure_tab_webview_loaded(tab);
++++        webkit_web_view_load_uri(tab->get_webview(), "about:blank");
++++        tab->set_title("New Tab");
++++        refresh_ui();
++++        return;
++++    }
++++    
++++    // Remove tab
++++    tabs_.erase(tabs_.begin() + active_tab_index_);
++++    
++++    // Adjust active index
++++    if (active_tab_index_ >= tabs_.size()) {
++++        active_tab_index_ = tabs_.size() - 1;
++++    }
++++    
++++    refresh_ui();
++++    if (!tabs_.empty()) {
++++        show_tab(active_tab_index_);
++++    }
++++}
++++
++++void BrowserWindow::next_tab() {
++++    if (tabs_.empty()) {
++++        return;
++++    }
++++    active_tab_index_ = (active_tab_index_ + 1) % tabs_.size();
++++    refresh_ui();
++++    show_tab(active_tab_index_);
++++}
++++
++++void BrowserWindow::previous_tab() {
++++    if (tabs_.empty()) {
++++        return;
++++    }
++++    active_tab_index_ = (active_tab_index_ == 0) ? tabs_.size() - 1 : active_tab_index_ - 1;
++++    refresh_ui();
++++    show_tab(active_tab_index_);
++++}
++++
++++void BrowserWindow::focus_address_bar() {
++++    gtk_widget_grab_focus(GTK_WIDGET(address_bar_));
++++    gtk_editable_select_region(GTK_EDITABLE(address_bar_), 0, -1);
++++}
++++
++++void BrowserWindow::update_tab_bar() {
++++    // Clear existing tab buttons
++++    GtkWidget* child = gtk_widget_get_first_child(GTK_WIDGET(tab_bar_));
++++    while (child) {
++++        GtkWidget* next = gtk_widget_get_next_sibling(child);
++++        gtk_box_remove(tab_bar_, child);
++++        child = next;
++++    }
++++    
++++    // Add tab buttons
++++    for (size_t i = 0; i < tabs_.size(); ++i) {
++++        Tab* tab = tabs_[i].get();
++++        if (!tab) {
++++            continue;
++++        }
++++        
++++        GtkButton* button = GTK_BUTTON(gtk_button_new());
++++        GtkBox* box = GTK_BOX(gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 4));
++++        
++++        GtkLabel* label = GTK_LABEL(gtk_label_new(tab->get_title().c_str()));
++++        gtk_box_append(box, GTK_WIDGET(label));
++++        
++++        GtkButton* close_btn = GTK_BUTTON(gtk_button_new_from_icon_name("window-close"));
++++        gtk_button_set_has_frame(close_btn, FALSE);
++++        g_signal_connect(close_btn, "clicked",
++++                         G_CALLBACK(on_tab_close_clicked), this);
++++        g_object_set_data(G_OBJECT(close_btn), "tab-index", GINT_TO_POINTER(i));
++++        gtk_box_append(box, GTK_WIDGET(close_btn));
++++        
++++        gtk_button_set_child(button, GTK_WIDGET(box));
++++        
++++        // Highlight active tab
++++        if (i == active_tab_index_) {
++++            gtk_widget_add_css_class(GTK_WIDGET(button), "active-tab");
++++        }
++++        
++++        gtk_box_append(tab_bar_, GTK_WIDGET(button));
++++    }
++++}
++++
++++void BrowserWindow::update_address_bar() {
++++    if (active_tab_index_ < tabs_.size()) {
++++        Tab* tab = tabs_[active_tab_index_].get();
++++        if (tab) {
++++            gtk_entry_set_text(address_bar_, tab->get_url().c_str());
++++        }
++++    }
++++}
++++
++++void BrowserWindow::update_notebook() {
++++    // Handled by show_tab()
++++}
++++
++++void BrowserWindow::refresh_ui() {
++++    update_tab_bar();
++++    update_address_bar();
++++}
++++
++++void BrowserWindow::ensure_tab_webview_loaded(Tab* tab) {
++++    if (!tab || tab->is_loaded()) {
++++        return;
++++    }
++++    
++++    tab->create_webview();
++++}
++++
++++void BrowserWindow::show_tab(size_t index) {
++++    if (index >= tabs_.size()) {
++++        return;
++++    }
++++    
++++    Tab* tab = tabs_[index].get();
++++    if (!tab) {
++++        return;
++++    }
++++    
++++    ensure_tab_webview_loaded(tab);
++++    
++++    // Remove all pages from notebook
++++    while (gtk_notebook_get_n_pages(notebook_) > 0) {
++++        gtk_notebook_remove_page(notebook_, 0);
++++    }
++++    
++++    // Add current tab's container
++++    GtkWidget* container = tab->get_container();
++++    if (container) {
++++        gtk_notebook_append_page(notebook_, container, nullptr);
++++    }
++++    
++++    tab->mark_active();
++++    refresh_ui();
++++}
++++
++++void BrowserWindow::on_address_bar_activated(GtkEntry* entry, gpointer user_data) {
++++    BrowserWindow* window = static_cast<BrowserWindow*>(user_data);
++++    const char* text = gtk_entry_get_text(entry);
++++    
++++    if (window->tabs_.empty()) {
++++        window->new_tab(text);
++++        return;
++++    }
++++    
++++    Tab* tab = window->tabs_[window->active_tab_index_].get();
++++    if (!tab) {
++++        return;
++++    }
++++    
++++    std::string url = text;
++++    if (url.find("://") == std::string::npos) {
++++        url = "https://" + url;
++++    }
++++    
++++    tab->set_url(url);
++++    window->ensure_tab_webview_loaded(tab);
++++    WebKitWebView* webview = tab->get_webview();
++++    if (webview) {
++++        webkit_web_view_load_uri(webview, url.c_str());
++++    }
++++    window->refresh_ui();
++++}
++++
++++void BrowserWindow::on_tab_close_clicked(GtkButton* button, gpointer user_data) {
++++    BrowserWindow* window = static_cast<BrowserWindow*>(user_data);
++++    gpointer index_ptr = g_object_get_data(G_OBJECT(button), "tab-index");
++++    if (index_ptr) {
++++        int index = GPOINTER_TO_INT(index_ptr);
++++        if (index >= 0 && index < static_cast<int>(window->tabs_.size())) {
++++            window->active_tab_index_ = index;
++++            window->close_current_tab();
++++        }
++++    }
++++}
+++diff --git a/ryxsurf-cpp/src/keyboard_handler.cpp b/ryxsurf-cpp/src/keyboard_handler.cpp
+++new file mode 100644
+++index 0000000..1362ca6
+++--- /dev/null
++++++ b/ryxsurf-cpp/src/keyboard_handler.cpp
+++@@ -0,0 +1,90 @@
++++#include "keyboard_handler.h"
++++#include "browser_window.h"
++++#include <gtk/gtk.h>
++++#include <gdk/gdkkeysyms.h>
++++
++++KeyboardHandler::KeyboardHandler(BrowserWindow* browser_window)
++++    : browser_window_(browser_window)
++++{
++++}
++++
++++KeyboardHandler::~KeyboardHandler() = default;
++++
++++void KeyboardHandler::setup_shortcuts(GtkWindow* window) {
++++    GtkEventController* controller = gtk_event_controller_key_new();
++++    g_signal_connect(controller, "key-pressed",
++++                     G_CALLBACK(on_key_pressed), this);
++++    GtkWidget* widget = GTK_WIDGET(window);
++++    gtk_widget_add_controller(widget, controller);
++++    g_object_set_data(G_OBJECT(widget), "keyboard-handler", this);
++++}
++++
++++gboolean KeyboardHandler::on_key_pressed(GtkEventControllerKey* controller,
++++                                         guint keyval,
++++                                         guint keycode,
++++                                         GdkModifierType state,
++++                                         gpointer user_data) {
++++    KeyboardHandler* handler = static_cast<KeyboardHandler*>(user_data);
++++    BrowserWindow* bw = handler->browser_window_;
++++    
++++    // Check for Ctrl modifier
++++    bool ctrl = (state & GDK_CONTROL_MASK) != 0;
++++    bool shift = (state & GDK_SHIFT_MASK) != 0;
++++    
++++    if (!ctrl) {
++++        return FALSE;
++++    }
++++    
++++    switch (keyval) {
++++        case GDK_KEY_t:
++++            // Ctrl+T: New tab
++++            bw->new_tab();
++++            return TRUE;
++++            
++++        case GDK_KEY_w:
++++            // Ctrl+W: Close current tab
++++            bw->close_current_tab();
++++            return TRUE;
++++            
++++        case GDK_KEY_Up:
++++            // Ctrl+Up: Previous tab
++++            bw->previous_tab();
++++            return TRUE;
++++            
++++        case GDK_KEY_Down:
++++            // Ctrl+Down: Next tab
++++            bw->next_tab();
++++            return TRUE;
++++            
++++        case GDK_KEY_Left:
++++            // Ctrl+Left: Previous session (placeholder)
++++            return TRUE;
++++            
++++        case GDK_KEY_Right:
++++            // Ctrl+Right: Next session (placeholder)
++++            return TRUE;
++++            
++++        case GDK_KEY_Tab:
++++            // Ctrl+Tab / Ctrl+Shift+Tab: Tab navigation (fallback)
++++            if (shift) {
++++                bw->previous_tab();
++++            } else {
++++                bw->next_tab();
++++            }
++++            return TRUE;
++++            
++++        case GDK_KEY_l:
++++            // Ctrl+L: Focus address bar
++++            bw->focus_address_bar();
++++            return TRUE;
++++            
++++        case GDK_KEY_s:
++++            if (shift) {
++++                // Ctrl+Shift+S: Save session snapshot (placeholder)
++++                return TRUE;
++++            }
++++            break;
++++    }
++++    
++++    return FALSE;
++++}
+++diff --git a/ryxsurf-cpp/src/main.cpp b/ryxsurf-cpp/src/main.cpp
+++new file mode 100644
+++index 0000000..5a32229
+++--- /dev/null
++++++ b/ryxsurf-cpp/src/main.cpp
+++@@ -0,0 +1,22 @@
++++#include "browser_window.h"
++++#include <gtk/gtk.h>
++++#include <webkit/webkit.h>
++++
++++int main(int argc, char* argv[]) {
++++    // Initialize GTK
++++    gtk_init(&argc, &argv);
++++    
++++    // Initialize WebKit with shared secondary process model
++++    webkit_web_context_set_process_model(
++++        webkit_web_context_get_default(),
++++        WEBKIT_PROCESS_MODEL_SHARED_SECONDARY_PROCESS);
++++    
++++    // Create and show browser window
++++    BrowserWindow browser;
++++    browser.show();
++++    
++++    // Run GTK main loop
++++    gtk_main();
++++    
++++    return 0;
++++}
+++diff --git a/ryxsurf-cpp/src/tab.cpp b/ryxsurf-cpp/src/tab.cpp
+++new file mode 100644
+++index 0000000..ffbcb5a
+++--- /dev/null
++++++ b/ryxsurf-cpp/src/tab.cpp
+++@@ -0,0 +1,119 @@
++++#include "tab.h"
++++#include <webkit/webkit.h>
++++#include <gtk/gtk.h>
++++
++++Tab::Tab(const std::string& url)
++++    : url_(url)
++++    , title_("New Tab")
++++    , webview_(nullptr)
++++    , container_(nullptr)
++++    , last_active_(std::chrono::steady_clock::now())
++++    , is_unloaded_(false)
++++{
++++}
++++
++++Tab::~Tab() {
++++    destroy_webview();
++++}
++++
++++WebKitWebView* Tab::get_webview() {
++++    if (!webview_ && !is_unloaded_) {
++++        create_webview();
++++    }
++++    return webview_;
++++}
++++
++++GtkWidget* Tab::get_container() {
++++    if (!container_ && !is_unloaded_) {
++++        create_webview();
++++    }
++++    return container_;
++++}
++++
++++void Tab::create_webview() {
++++    if (webview_) {
++++        return;
++++    }
++++    
++++    // Create WebKit settings for minimal resource usage
++++    WebKitSettings* settings = webkit_settings_new();
++++    webkit_settings_set_enable_plugins(settings, FALSE);
++++    webkit_settings_set_enable_java(settings, FALSE);
++++    webkit_settings_set_enable_media_stream(settings, FALSE);
++++    webkit_settings_set_enable_mediasource(settings, FALSE);
++++    webkit_settings_set_hardware_acceleration_policy(
++++        settings, WEBKIT_HARDWARE_ACCELERATION_POLICY_ALWAYS);
++++    
++++    // Create WebView
++++    webview_ = WEBKIT_WEB_VIEW(webkit_web_view_new_with_settings(settings));
++++    g_object_unref(settings);
++++    
++++    // Create container
++++    container_ = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
++++    gtk_box_append(GTK_BOX(container_), GTK_WIDGET(webview_));
++++    
++++    // Load URL if set
++++    if (!url_.empty() && url_ != "about:blank") {
++++        webkit_web_view_load_uri(webview_, url_.c_str());
++++    }
++++    
++++    // Connect title changed signal
++++    g_signal_connect(webview_, "notify::title",
++++                     G_CALLBACK(+[](WebKitWebView* view, GParamSpec*, gpointer data) {
++++                         Tab* tab = static_cast<Tab*>(data);
++++                         char* title = webkit_web_view_get_title(view);
++++                         if (title) {
++++                             tab->set_title(title);
++++                             g_free(title);
++++                         }
++++                     }), this);
++++    
++++    mark_active();
++++    is_unloaded_ = false;
++++}
++++
++++void Tab::destroy_webview() {
++++    if (webview_) {
++++        if (container_) {
++++            GtkWidget* parent = gtk_widget_get_parent(container_);
++++            if (parent) {
++++                gtk_box_remove(GTK_BOX(parent), container_);
++++            }
++++            gtk_widget_unparent(container_);
++++        }
++++        g_object_unref(webview_);
++++        webview_ = nullptr;
++++        container_ = nullptr;
++++    }
++++}
++++
++++void Tab::unload() {
++++    if (is_unloaded_ || !webview_) {
++++        return;
++++    }
++++    
++++    // Save URL before unloading
++++    char* uri = webkit_web_view_get_uri(webview_);
++++    if (uri) {
++++        url_ = uri;
++++        g_free(uri);
++++    }
++++    
++++    destroy_webview();
++++    is_unloaded_ = true;
++++}
++++
++++void Tab::restore() {
++++    if (!is_unloaded_) {
++++        return;
++++    }
++++    
++++    create_webview();
++++    if (!url_.empty() && url_ != "about:blank") {
++++        webkit_web_view_load_uri(webview_, url_.c_str());
++++    }
++++}
++++
++++void Tab::mark_active() {
++++    last_active_ = std::chrono::steady_clock::now();
++++}
+++diff --git a/ryxsurf-cpp/tests/test_tab.cpp b/ryxsurf-cpp/tests/test_tab.cpp
+++new file mode 100644
+++index 0000000..fe97a06
+++--- /dev/null
++++++ b/ryxsurf-cpp/tests/test_tab.cpp
+++@@ -0,0 +1,48 @@
++++#define CATCH_CONFIG_MAIN
++++#include <catch2/catch.hpp>
++++#include "../include/tab.h"
++++#include <chrono>
++++#include <thread>
++++
++++TEST_CASE("Tab creation", "[tab]") {
++++    Tab tab("https://example.com");
++++    
++++    REQUIRE(tab.get_url() == "https://example.com");
++++    REQUIRE(tab.get_title() == "New Tab");
++++    REQUIRE_FALSE(tab.is_loaded());
++++    REQUIRE_FALSE(tab.is_unloaded());
++++}
++++
++++TEST_CASE("Tab lazy loading", "[tab]") {
++++    Tab tab("https://example.com");
++++    
++++    REQUIRE_FALSE(tab.is_loaded());
++++    
++++    // WebView should be created on first access
++++    // Note: This requires GTK/WebKit initialization, so we test metadata only
++++    REQUIRE(tab.get_url() == "https://example.com");
++++}
++++
++++TEST_CASE("Tab activity tracking", "[tab]") {
++++    Tab tab;
++++    
++++    auto time1 = tab.get_last_active();
++++    std::this_thread::sleep_for(std::chrono::milliseconds(10));
++++    tab.mark_active();
++++    auto time2 = tab.get_last_active();
++++    
++++    REQUIRE(time2 > time1);
++++}
++++
++++TEST_CASE("Tab unload/restore", "[tab]") {
++++    Tab tab("https://example.com");
++++    
++++    REQUIRE_FALSE(tab.is_unloaded());
++++    
++++    // Unload should mark as unloaded
++++    tab.unload();
++++    REQUIRE(tab.is_unloaded());
++++    
++++    // URL should be preserved
++++    REQUIRE(tab.get_url() == "https://example.com");
++++}
+++-- 
+++2.52.0
+++
++diff --git a/ryxsurf-cpp/plan.md b/ryxsurf-cpp/plan.md
++new file mode 100644
++index 0000000..5110bcd
++--- /dev/null
+++++ b/ryxsurf-cpp/plan.md
++@@ -0,0 +1,178 @@
+++# Development Plan
+++
+++## Milestone 1: PoC ✅ Complete
+++
+++**Status**: Complete
+++
+++**Deliverables**:
+++- [x] Basic GTK4 window
+++- [x] WebKit6 integration
+++- [x] Keyboard shortcuts
+++- [x] Lazy WebView instantiation
+++- [x] Tab management
+++- [x] Meson build system
+++- [x] Unit tests skeleton
+++- [x] Performance test script
+++
+++**Complexity**: Low-Medium
+++
+++---
+++
+++## Milestone 2: Core Data Models
+++
+++**Status**: Pending
+++
+++**Tasks**:
+++1. Implement Workspace struct
+++2. Implement Session struct
+++3. Implement TabMeta struct (enhanced)
+++4. Update SessionManager with workspace/session hierarchy
+++
+++**Complexity**: Low
+++
+++**Estimated Time**: 1 day
+++
+++---
+++
+++## Milestone 3: Session/Tab Manager + Tests
+++
+++**Status**: Pending
+++
+++**Tasks**:
+++1. Implement SessionManager with in-memory operations
+++2. Unit tests for create/destroy/switch
+++3. Auto-close empty sessions (except Overview)
+++4. Tab navigation within sessions
+++
+++**Complexity**: Medium
+++
+++**Estimated Time**: 2-3 days
+++
+++---
+++
+++## Milestone 4: Lazy WebView Factory
+++
+++**Status**: Pending
+++
+++**Tasks**:
+++1. Implement WebViewFactory for on-demand instantiation
+++2. Snapshot placeholder renderer
+++3. Memory-efficient WebView creation
+++
+++**Complexity**: Medium
+++
+++**Estimated Time**: 2 days
+++
+++---
+++
+++## Milestone 5: Tab Unload/Restore & Snapshot
+++
+++**Status**: Pending
+++
+++**Tasks**:
+++1. Implement unload logic (configurable timeout, default 5 min)
+++2. Snapshot PNG + minimal HTML generation
+++3. Restore logic with URL and history state
+++4. Tests for unload/restore behavior
+++
+++**Complexity**: Medium-High
+++
+++**Estimated Time**: 3-4 days
+++
+++---
+++
+++## Milestone 6: Persistence
+++
+++**Status**: Pending
+++
+++**Tasks**:
+++1. Encrypted SQLite schema for metadata
+++2. Argon2id KDF + libsodium encryption wrapper
+++3. Autosave & graceful exit restore
+++4. CLI export/import
+++
+++**Complexity**: Medium-High
+++
+++**Estimated Time**: 4-5 days
+++
+++---
+++
+++## Milestone 7: Password Manager
+++
+++**Status**: Pending
+++
+++**Tasks**:
+++1. Integrate libsecret (primary)
+++2. Encrypted SQLite fallback
+++3. UI for credential management (secure dialog)
+++4. Autofill integration
+++
+++**Complexity**: High
+++
+++**Estimated Time**: 5-7 days
+++
+++---
+++
+++## Milestone 8: IPC / Automation
+++
+++**Status**: Pending
+++
+++**Tasks**:
+++1. UNIX socket + simple JSON RPC
+++2. Open URL, list sessions, export commands
+++3. Sample scripts in examples/
+++
+++**Complexity**: Low-Medium
+++
+++**Estimated Time**: 2-3 days
+++
+++---
+++
+++## Milestone 9: UI Polish & CSS
+++
+++**Status**: Pending
+++
+++**Tasks**:
+++1. Minimal CSS theme
+++2. GPU animations (optional flag)
+++3. Tab visuals (vertical/horizontal modes)
+++4. Session separators (persistent)
+++
+++**Complexity**: Medium
+++
+++**Estimated Time**: 3-4 days
+++
+++---
+++
+++## Milestone 10: Performance Tuning
+++
+++**Status**: Pending
+++
+++**Tasks**:
+++1. LTO, custom allocators (optional)
+++2. WebKit tuning (cache size, process reuse)
+++3. Measure and optimize hotspots
+++4. Performance regression tests
+++
+++**Complexity**: Medium-High
+++
+++**Estimated Time**: 4-5 days
+++
+++---
+++
+++## Total Estimated Time
+++
+++**Minimum**: ~30 days (focused development)
+++**Realistic**: ~45-60 days (with testing and refinement)
+++
+++## Priority Order
+++
+++1. Milestone 2 (Core Data Models) - Foundation
+++2. Milestone 3 (Session/Tab Manager) - Core functionality
+++3. Milestone 4 (WebView Factory) - Memory efficiency
+++4. Milestone 5 (Unload/Restore) - Core memory efficiency feature
+++5. Milestone 6 (Persistence) - Data persistence
+++6. Milestone 7 (Password Manager) - Security feature
+++7. Milestone 9 (UI Polish) - User experience
+++8. Milestone 10 (Performance) - Validate resource efficiency
+++9. Milestone 8 (IPC) - Advanced feature
++diff --git a/ryxsurf-cpp/repo-tree.txt b/ryxsurf-cpp/repo-tree.txt
++new file mode 100644
++index 0000000..1857895
++--- /dev/null
+++++ b/ryxsurf-cpp/repo-tree.txt
++@@ -0,0 +1,13 @@
+++ryxsurf-cpp/include/browser_window.h
+++ryxsurf-cpp/include/keyboard_handler.h
+++ryxsurf-cpp/include/tab.h
+++ryxsurf-cpp/meson.build
+++ryxsurf-cpp/meson_options.txt
+++ryxsurf-cpp/patches/0001-poC-minimal-GTK4-WebKit-app-keyboard-nav.patch
+++ryxsurf-cpp/perf/run_perf.sh
+++ryxsurf-cpp/repo-tree.txt
+++ryxsurf-cpp/src/browser_window.cpp
+++ryxsurf-cpp/src/keyboard_handler.cpp
+++ryxsurf-cpp/src/main.cpp
+++ryxsurf-cpp/src/tab.cpp
+++ryxsurf-cpp/tests/test_tab.cpp
++-- 
++2.52.0
++
+diff --git a/ryxsurf-cpp/src/browser_window.cpp b/ryxsurf-cpp/src/browser_window.cpp
+index cbf9d6f..dc83678 100644
+--- a/ryxsurf-cpp/src/browser_window.cpp
++++ b/ryxsurf-cpp/src/browser_window.cpp
+@@ -1,4 +1,5 @@
+ #include "browser_window.h"
++#include "session_manager.h"
+ #include <gtk/gtk.h>
+ #include <webkit/webkit.h>
+ #include <iostream>
+@@ -9,7 +10,7 @@ BrowserWindow::BrowserWindow()
+     , tab_bar_(nullptr)
+     , address_bar_(nullptr)
+     , notebook_(nullptr)
+-    , active_tab_index_(0)
++    , session_manager_(std::make_unique<SessionManager>())
+     , keyboard_handler_(std::make_unique<KeyboardHandler>(this))
+ {
+     // Create main window
+@@ -41,8 +42,10 @@ BrowserWindow::BrowserWindow()
+     // Setup keyboard shortcuts
+     keyboard_handler_->setup_shortcuts(window_);
+     
+-    // Create initial tab
+-    new_tab();
++    // Create initial tab via session manager
++    session_manager_->new_tab();
++    refresh_ui();
++    update_notebook();
+     
+     // Connect window close
+     g_signal_connect(window_, "close-request",
+@@ -63,67 +66,80 @@ void BrowserWindow::show() {
+ }
+ 
+ void BrowserWindow::new_tab(const std::string& url) {
+-    auto tab = std::make_unique<Tab>(url.empty() ? "about:blank" : url);
+-    Tab* tab_ptr = tab.get();
+-    tabs_.push_back(std::move(tab));
+-    active_tab_index_ = tabs_.size() - 1;
++    Tab* tab = session_manager_->new_tab(url.empty() ? "about:blank" : url);
++    if (!tab) {
++        return;
++    }
+     
+     refresh_ui();
+-    show_tab(active_tab_index_);
++    Session* session = session_manager_->get_current_session();
++    if (session) {
++        show_tab(session->get_active_tab_index());
++    }
+     
+     // Load URL if provided
+     if (!url.empty()) {
+-        ensure_tab_webview_loaded(tab_ptr);
+-        webkit_web_view_load_uri(tab_ptr->get_webview(), url.c_str());
++        ensure_tab_webview_loaded(tab);
++        WebKitWebView* webview = tab->get_webview();
++        if (webview) {
++            webkit_web_view_load_uri(webview, url.c_str());
++        }
+     }
+ }
+ 
+ void BrowserWindow::close_current_tab() {
+-    if (tabs_.empty()) {
++    Session* session = session_manager_->get_current_session();
++    if (!session) {
++        return;
++    }
++    
++    size_t tab_count = session->get_tab_count();
++    if (tab_count == 0) {
+         return;
+     }
+     
+-    if (tabs_.size() == 1) {
++    if (tab_count == 1) {
+         // Keep at least one tab
+-        Tab* tab = tabs_[0].get();
+-        tab->set_url("about:blank");
+-        ensure_tab_webview_loaded(tab);
+-        webkit_web_view_load_uri(tab->get_webview(), "about:blank");
+-        tab->set_title("New Tab");
++        Tab* tab = session->get_active_tab();
++        if (tab) {
++            tab->set_url("about:blank");
++            ensure_tab_webview_loaded(tab);
++            WebKitWebView* webview = tab->get_webview();
++            if (webview) {
++                webkit_web_view_load_uri(webview, "about:blank");
++            }
++            tab->set_title("New Tab");
++        }
+         refresh_ui();
+         return;
+     }
+     
+-    // Remove tab
+-    tabs_.erase(tabs_.begin() + active_tab_index_);
+-    
+-    // Adjust active index
+-    if (active_tab_index_ >= tabs_.size()) {
+-        active_tab_index_ = tabs_.size() - 1;
+-    }
++    // Remove tab via session manager
++    session_manager_->close_current_tab();
+     
+     refresh_ui();
+-    if (!tabs_.empty()) {
+-        show_tab(active_tab_index_);
++    session = session_manager_->get_current_session();
++    if (session && session->get_tab_count() > 0) {
++        show_tab(session->get_active_tab_index());
+     }
+ }
+ 
+ void BrowserWindow::next_tab() {
+-    if (tabs_.empty()) {
+-        return;
+-    }
+-    active_tab_index_ = (active_tab_index_ + 1) % tabs_.size();
++    session_manager_->next_tab();
+     refresh_ui();
+-    show_tab(active_tab_index_);
++    Session* session = session_manager_->get_current_session();
++    if (session) {
++        show_tab(session->get_active_tab_index());
++    }
+ }
+ 
+ void BrowserWindow::previous_tab() {
+-    if (tabs_.empty()) {
+-        return;
+-    }
+-    active_tab_index_ = (active_tab_index_ == 0) ? tabs_.size() - 1 : active_tab_index_ - 1;
++    session_manager_->previous_tab();
+     refresh_ui();
+-    show_tab(active_tab_index_);
++    Session* session = session_manager_->get_current_session();
++    if (session) {
++        show_tab(session->get_active_tab_index());
++    }
+ }
+ 
+ void BrowserWindow::focus_address_bar() {
+@@ -140,9 +156,14 @@ void BrowserWindow::update_tab_bar() {
+         child = next;
+     }
+     
++    Session* session = session_manager_->get_current_session();
++    if (!session) {
++        return;
++    }
++    
+     // Add tab buttons
+-    for (size_t i = 0; i < tabs_.size(); ++i) {
+-        Tab* tab = tabs_[i].get();
++    for (size_t i = 0; i < session->get_tab_count(); ++i) {
++        Tab* tab = session->get_tab(i);
+         if (!tab) {
+             continue;
+         }
+@@ -163,7 +184,7 @@ void BrowserWindow::update_tab_bar() {
+         gtk_button_set_child(button, GTK_WIDGET(box));
+         
+         // Highlight active tab
+-        if (i == active_tab_index_) {
++        if (i == session->get_active_tab_index()) {
+             gtk_widget_add_css_class(GTK_WIDGET(button), "active-tab");
+         }
+         
+@@ -172,11 +193,9 @@ void BrowserWindow::update_tab_bar() {
+ }
+ 
+ void BrowserWindow::update_address_bar() {
+-    if (active_tab_index_ < tabs_.size()) {
+-        Tab* tab = tabs_[active_tab_index_].get();
+-        if (tab) {
+-            gtk_entry_set_text(address_bar_, tab->get_url().c_str());
+-        }
++    Tab* tab = session_manager_->get_current_tab();
++    if (tab) {
++        gtk_entry_set_text(address_bar_, tab->get_url().c_str());
+     }
+ }
+ 
+@@ -198,11 +217,12 @@ void BrowserWindow::ensure_tab_webview_loaded(Tab* tab) {
+ }
+ 
+ void BrowserWindow::show_tab(size_t index) {
+-    if (index >= tabs_.size()) {
++    Session* session = session_manager_->get_current_session();
++    if (!session) {
+         return;
+     }
+     
+-    Tab* tab = tabs_[index].get();
++    Tab* tab = session->get_tab(index);
+     if (!tab) {
+         return;
+     }
+@@ -228,13 +248,9 @@ void BrowserWindow::on_address_bar_activated(GtkEntry* entry, gpointer user_data
+     BrowserWindow* window = static_cast<BrowserWindow*>(user_data);
+     const char* text = gtk_entry_get_text(entry);
+     
+-    if (window->tabs_.empty()) {
+-        window->new_tab(text);
+-        return;
+-    }
+-    
+-    Tab* tab = window->tabs_[window->active_tab_index_].get();
++    Tab* tab = window->session_manager_->get_current_tab();
+     if (!tab) {
++        window->new_tab(text);
+         return;
+     }
+     
+@@ -257,8 +273,9 @@ void BrowserWindow::on_tab_close_clicked(GtkButton* button, gpointer user_data)
+     gpointer index_ptr = g_object_get_data(G_OBJECT(button), "tab-index");
+     if (index_ptr) {
+         int index = GPOINTER_TO_INT(index_ptr);
+-        if (index >= 0 && index < static_cast<int>(window->tabs_.size())) {
+-            window->active_tab_index_ = index;
++        Session* session = window->session_manager_->get_current_session();
++        if (session && index >= 0 && index < static_cast<int>(session->get_tab_count())) {
++            session->set_active_tab(index);
+             window->close_current_tab();
+         }
+     }
+diff --git a/ryxsurf-cpp/src/session.cpp b/ryxsurf-cpp/src/session.cpp
+new file mode 100644
+index 0000000..838d30a
+--- /dev/null
++++ b/ryxsurf-cpp/src/session.cpp
+@@ -0,0 +1,69 @@
++#include "session.h"
++#include <algorithm>
++
++Session::Session(const std::string& name)
++    : name_(name)
++    , active_tab_index_(0)
++    , is_overview_(false)
++    , created_at_(std::chrono::system_clock::now())
++    , updated_at_(std::chrono::system_clock::now())
++{
++}
++
++Session::~Session() = default;
++
++Tab* Session::add_tab(const std::string& url) {
++    auto tab = std::make_unique<Tab>(url);
++    Tab* tab_ptr = tab.get();
++    tabs_.push_back(std::move(tab));
++    active_tab_index_ = tabs_.size() - 1;
++    is_overview_ = false;
++    mark_updated();
++    return tab_ptr;
++}
++
++void Session::remove_tab(size_t index) {
++    if (index >= tabs_.size()) {
++        return;
++    }
++    
++    tabs_.erase(tabs_.begin() + index);
++    
++    // Adjust active tab index
++    if (tabs_.empty()) {
++        active_tab_index_ = 0;
++        is_overview_ = true;
++    } else if (active_tab_index_ >= tabs_.size()) {
++        active_tab_index_ = tabs_.size() - 1;
++    }
++    
++    mark_updated();
++}
++
++Tab* Session::get_tab(size_t index) {
++    if (index >= tabs_.size()) {
++        return nullptr;
++    }
++    return tabs_[index].get();
++}
++
++void Session::set_active_tab(size_t index) {
++    if (index < tabs_.size()) {
++        active_tab_index_ = index;
++        if (tabs_[index]) {
++            tabs_[index]->mark_active();
++        }
++        mark_updated();
++    }
++}
++
++Tab* Session::get_active_tab() {
++    if (tabs_.empty()) {
++        return nullptr;
++    }
++    return tabs_[active_tab_index_].get();
++}
++
++void Session::mark_updated() {
++    updated_at_ = std::chrono::system_clock::now();
++}
+diff --git a/ryxsurf-cpp/src/session_manager.cpp b/ryxsurf-cpp/src/session_manager.cpp
+new file mode 100644
+index 0000000..98b3b52
+--- /dev/null
++++ b/ryxsurf-cpp/src/session_manager.cpp
+@@ -0,0 +1,159 @@
++#include "session_manager.h"
++#include <algorithm>
++
++SessionManager::SessionManager()
++    : current_workspace_index_(0)
++{
++    ensure_default_workspace();
++}
++
++SessionManager::~SessionManager() = default;
++
++void SessionManager::ensure_default_workspace() {
++    if (workspaces_.empty()) {
++        auto workspace = std::make_unique<Workspace>("Main");
++        workspaces_.push_back(std::move(workspace));
++        current_workspace_index_ = 0;
++        
++        // Create default session "Overview" in the workspace
++        Workspace* ws = workspaces_[0].get();
++        Session* session = ws->add_session("Overview");
++        session->set_overview(true);
++    }
++}
++
++Workspace* SessionManager::add_workspace(const std::string& name) {
++    auto workspace = std::make_unique<Workspace>(name);
++    Workspace* workspace_ptr = workspace.get();
++    workspaces_.push_back(std::move(workspace));
++    return workspace_ptr;
++}
++
++Workspace* SessionManager::get_workspace(size_t index) {
++    if (index >= workspaces_.size()) {
++        return nullptr;
++    }
++    return workspaces_[index].get();
++}
++
++Workspace* SessionManager::get_current_workspace() {
++    ensure_default_workspace();
++    if (current_workspace_index_ >= workspaces_.size()) {
++        current_workspace_index_ = 0;
++    }
++    return workspaces_[current_workspace_index_].get();
++}
++
++Session* SessionManager::get_current_session() {
++    Workspace* ws = get_current_workspace();
++    if (!ws) {
++        return nullptr;
++    }
++    return ws->get_active_session();
++}
++
++Tab* SessionManager::get_current_tab() {
++    Session* session = get_current_session();
++    if (!session) {
++        return nullptr;
++    }
++    return session->get_active_tab();
++}
++
++void SessionManager::switch_workspace(size_t index) {
++    if (index < workspaces_.size()) {
++        current_workspace_index_ = index;
++    }
++}
++
++void SessionManager::switch_session(size_t index) {
++    Workspace* ws = get_current_workspace();
++    if (ws) {
++        ws->set_active_session(index);
++    }
++}
++
++void SessionManager::switch_tab(size_t index) {
++    Session* session = get_current_session();
++    if (session) {
++        session->set_active_tab(index);
++    }
++}
++
++Tab* SessionManager::new_tab(const std::string& url) {
++    Session* session = get_current_session();
++    if (!session) {
++        ensure_default_workspace();
++        Workspace* ws = get_current_workspace();
++        session = ws->add_session("Session 1");
++    }
++    return session->add_tab(url);
++}
++
++void SessionManager::close_current_tab() {
++    Session* session = get_current_session();
++    if (!session) {
++        return;
++    }
++    
++    size_t active_index = session->get_active_tab_index();
++    session->remove_tab(active_index);
++    
++    // If session becomes empty and is not overview, close it
++    if (session->is_empty() && !session->is_overview()) {
++        Workspace* ws = get_current_workspace();
++        if (ws) {
++            // Find session index
++            for (size_t i = 0; i < ws->get_session_count(); ++i) {
++                if (ws->get_session(i) == session) {
++                    ws->remove_session(i);
++                    break;
++                }
++            }
++        }
++    }
++}
++
++void SessionManager::next_tab() {
++    Session* session = get_current_session();
++    if (!session || session->get_tab_count() == 0) {
++        return;
++    }
++    
++    size_t current = session->get_active_tab_index();
++    size_t next = (current + 1) % session->get_tab_count();
++    session->set_active_tab(next);
++}
++
++void SessionManager::previous_tab() {
++    Session* session = get_current_session();
++    if (!session || session->get_tab_count() == 0) {
++        return;
++    }
++    
++    size_t current = session->get_active_tab_index();
++    size_t next = (current == 0) ? session->get_tab_count() - 1 : current - 1;
++    session->set_active_tab(next);
++}
++
++void SessionManager::next_session() {
++    Workspace* ws = get_current_workspace();
++    if (!ws || ws->get_session_count() == 0) {
++        return;
++    }
++    
++    size_t current = ws->get_active_session_index();
++    size_t next = (current + 1) % ws->get_session_count();
++    ws->set_active_session(next);
++}
++
++void SessionManager::previous_session() {
++    Workspace* ws = get_current_workspace();
++    if (!ws || ws->get_session_count() == 0) {
++        return;
++    }
++    
++    size_t current = ws->get_active_session_index();
++    size_t next = (current == 0) ? ws->get_session_count() - 1 : current - 1;
++    ws->set_active_session(next);
++}
+diff --git a/ryxsurf-cpp/src/workspace.cpp b/ryxsurf-cpp/src/workspace.cpp
+new file mode 100644
+index 0000000..69deb9f
+--- /dev/null
++++ b/ryxsurf-cpp/src/workspace.cpp
+@@ -0,0 +1,64 @@
++#include "workspace.h"
++#include "session.h"
++#include <algorithm>
++
++Workspace::Workspace(const std::string& name)
++    : name_(name)
++    , active_session_index_(0)
++    , created_at_(std::chrono::system_clock::now())
++    , updated_at_(std::chrono::system_clock::now())
++{
++}
++
++Workspace::~Workspace() = default;
++
++Session* Workspace::add_session(const std::string& name) {
++    auto session = std::make_unique<Session>(name);
++    Session* session_ptr = session.get();
++    sessions_.push_back(std::move(session));
++    active_session_index_ = sessions_.size() - 1;
++    mark_updated();
++    return session_ptr;
++}
++
++void Workspace::remove_session(size_t index) {
++    if (index >= sessions_.size()) {
++        return;
++    }
++    
++    sessions_.erase(sessions_.begin() + index);
++    
++    // Adjust active session index
++    if (sessions_.empty()) {
++        active_session_index_ = 0;
++    } else if (active_session_index_ >= sessions_.size()) {
++        active_session_index_ = sessions_.size() - 1;
++    }
++    
++    mark_updated();
++}
++
++Session* Workspace::get_session(size_t index) {
++    if (index >= sessions_.size()) {
++        return nullptr;
++    }
++    return sessions_[index].get();
++}
++
++void Workspace::set_active_session(size_t index) {
++    if (index < sessions_.size()) {
++        active_session_index_ = index;
++        mark_updated();
++    }
++}
++
++Session* Workspace::get_active_session() {
++    if (sessions_.empty()) {
++        return nullptr;
++    }
++    return sessions_[active_session_index_].get();
++}
++
++void Workspace::mark_updated() {
++    updated_at_ = std::chrono::system_clock::now();
++}
+diff --git a/ryxsurf-cpp/tests/test_session_manager.cpp b/ryxsurf-cpp/tests/test_session_manager.cpp
+new file mode 100644
+index 0000000..035ffb0
+--- /dev/null
++++ b/ryxsurf-cpp/tests/test_session_manager.cpp
+@@ -0,0 +1,103 @@
++#define CATCH_CONFIG_MAIN
++#include <catch2/catch.hpp>
++#include "../include/session_manager.h"
++#include "../include/workspace.h"
++#include "../include/session.h"
++
++TEST_CASE("SessionManager initialization", "[session_manager]") {
++    SessionManager sm;
++    
++    REQUIRE(sm.get_workspace_count() > 0);
++    REQUIRE(sm.get_current_workspace() != nullptr);
++    REQUIRE(sm.get_current_session() != nullptr);
++}
++
++TEST_CASE("Workspace creation", "[workspace]") {
++    Workspace ws("Test");
++    
++    REQUIRE(ws.get_name() == "Test");
++    REQUIRE(ws.get_session_count() == 0);
++}
++
++TEST_CASE("Session creation", "[session]") {
++    Session session("TestSession");
++    
++    REQUIRE(session.get_name() == "TestSession");
++    REQUIRE(session.is_empty());
++    REQUIRE_FALSE(session.is_overview());
++}
++
++TEST_CASE("Workspace session management", "[workspace]") {
++    Workspace ws("Test");
++    
++    Session* s1 = ws.add_session("Session1");
++    REQUIRE(s1 != nullptr);
++    REQUIRE(ws.get_session_count() == 1);
++    
++    Session* s2 = ws.add_session("Session2");
++    REQUIRE(ws.get_session_count() == 2);
++    
++    REQUIRE(ws.get_active_session() == s2);
++    
++    ws.set_active_session(0);
++    REQUIRE(ws.get_active_session() == s1);
++}
++
++TEST_CASE("Session tab management", "[session]") {
++    Session session("Test");
++    
++    Tab* t1 = session.add_tab("https://example.com");
++    REQUIRE(t1 != nullptr);
++    REQUIRE(session.get_tab_count() == 1);
++    REQUIRE_FALSE(session.is_empty());
++    
++    Tab* t2 = session.add_tab("https://github.com");
++    REQUIRE(session.get_tab_count() == 2);
++    
++    REQUIRE(session.get_active_tab() == t2);
++    
++    session.set_active_tab(0);
++    REQUIRE(session.get_active_tab() == t1);
++}
++
++TEST_CASE("SessionManager tab operations", "[session_manager]") {
++    SessionManager sm;
++    
++    Tab* tab = sm.new_tab("https://example.com");
++    REQUIRE(tab != nullptr);
++    REQUIRE(sm.get_current_tab() == tab);
++    
++    sm.new_tab("https://github.com");
++    REQUIRE(sm.get_current_tab() != tab);
++    
++    sm.previous_tab();
++    REQUIRE(sm.get_current_tab() == tab);
++}
++
++TEST_CASE("Session auto-close empty sessions", "[session_manager]") {
++    SessionManager sm;
++    
++    // Create a new session with a tab
++    Tab* tab = sm.new_tab("https://example.com");
++    Session* session = sm.get_current_session();
++    REQUIRE(session != nullptr);
++    REQUIRE_FALSE(session->is_overview());
++    
++    // Close the tab
++    sm.close_current_tab();
++    
++    // Session should be closed if not overview
++    // (Overview session should remain)
++    Session* new_session = sm.get_current_session();
++    REQUIRE(new_session != nullptr);
++}
++
++TEST_CASE("Overview session persistence", "[session]") {
++    Session session("Overview");
++    session.set_overview(true);
++    
++    REQUIRE(session.is_overview());
++    
++    // Overview session should remain even when empty
++    REQUIRE(session.is_empty() || !session.is_empty());  // Can be empty
++}
+-- 
+2.52.0
+
diff --git a/ryxsurf-cpp/patches/0004-perf-tab-unload-restore-snapshot.patch b/ryxsurf-cpp/patches/0004-perf-tab-unload-restore-snapshot.patch
new file mode 100644
index 0000000..359ddbd
--- /dev/null
+++ b/ryxsurf-cpp/patches/0004-perf-tab-unload-restore-snapshot.patch
@@ -0,0 +1,625 @@
+From 3c709854d1713f9aabf67a7376c45074e36fd892 Mon Sep 17 00:00:00 2001
+From: Tobito320 <ahmedhdplay12345@gmail.com>
+Date: Thu, 11 Dec 2025 19:42:43 +0100
+Subject: [PATCH 4/4] perf(tab): unload/restore + snapshot
+
+Implemented tab unload/restore mechanism with snapshots:
+- TabUnloadManager: automatic unloading based on inactivity (5 min default)
+- SnapshotManager: PNG + HTML snapshot generation and restoration
+- Configurable timeout and max loaded tabs
+- Periodic check every 60 seconds
+- Snapshot stored in XDG_DATA_HOME/ryxsurf/snapshots/
+
+Features:
+- Unload inactive tabs after configurable timeout (default 5 minutes)
+- Limit max loaded tabs (default 8), unload excess oldest first
+- Create PNG snapshot (max 512px width) + minimal HTML state
+- Restore tab from snapshot on focus
+- Preserve URL and title across unload/restore cycle
+
+Integration:
+- BrowserWindow uses TabUnloadManager for periodic checks
+- Tab::restore() loads WebView and URL from snapshot
+- Automatic snapshot creation before unload
+
+Tests:
+- Unit tests for TabUnloadManager configuration
+- Tab unload/restore cycle tests
+- SnapshotManager path generation tests
+---
+ ryxsurf-cpp/include/browser_window.h     |   1 +
+ ryxsurf-cpp/include/snapshot_manager.h   |  40 ++++++
+ ryxsurf-cpp/include/tab.h                |   2 +
+ ryxsurf-cpp/include/tab_unload_manager.h |  46 +++++++
+ ryxsurf-cpp/meson.build                  |   4 +
+ ryxsurf-cpp/src/browser_window.cpp       |  27 ++++
+ ryxsurf-cpp/src/snapshot_manager.cpp     | 164 +++++++++++++++++++++++
+ ryxsurf-cpp/src/tab.cpp                  |   6 +-
+ ryxsurf-cpp/src/tab_unload_manager.cpp   | 113 ++++++++++++++++
+ ryxsurf-cpp/tests/test_unload.cpp        |  44 ++++++
+ 10 files changed, 446 insertions(+), 1 deletion(-)
+ create mode 100644 ryxsurf-cpp/include/snapshot_manager.h
+ create mode 100644 ryxsurf-cpp/include/tab_unload_manager.h
+ create mode 100644 ryxsurf-cpp/src/snapshot_manager.cpp
+ create mode 100644 ryxsurf-cpp/src/tab_unload_manager.cpp
+ create mode 100644 ryxsurf-cpp/tests/test_unload.cpp
+
+diff --git a/ryxsurf-cpp/include/browser_window.h b/ryxsurf-cpp/include/browser_window.h
+index 283f28c..3d14a56 100644
+--- a/ryxsurf-cpp/include/browser_window.h
++++ b/ryxsurf-cpp/include/browser_window.h
+@@ -7,6 +7,7 @@
+ #include "tab.h"
+ #include "keyboard_handler.h"
+ #include "session_manager.h"
++#include <glib.h>
+ 
+ /**
+  * BrowserWindow is the main GTK4 window containing the browser UI.
+diff --git a/ryxsurf-cpp/include/snapshot_manager.h b/ryxsurf-cpp/include/snapshot_manager.h
+new file mode 100644
+index 0000000..ef7bb3b
+--- /dev/null
++++ b/ryxsurf-cpp/include/snapshot_manager.h
+@@ -0,0 +1,40 @@
++#pragma once
++
++#include <string>
++#include <filesystem>
++#include <memory>
++
++class Tab;  // Forward declaration
++
++/**
++ * SnapshotManager handles tab snapshot generation and restoration.
++ * 
++ * Snapshots are stored as PNG images + minimal HTML state.
++ * Ownership: SnapshotManager does not own Tab objects.
++ */
++class SnapshotManager {
++public:
++    SnapshotManager();
++    ~SnapshotManager();
++
++    // Non-copyable, movable
++    SnapshotManager(const SnapshotManager&) = delete;
++    SnapshotManager& operator=(const SnapshotManager&) = delete;
++    SnapshotManager(SnapshotManager&&) = default;
++    SnapshotManager& operator=(SnapshotManager&&) = default;
++
++    // Snapshot operations
++    std::string create_snapshot(Tab* tab);
++    bool restore_snapshot(Tab* tab, const std::string& snapshot_path);
++    void delete_snapshot(const std::string& snapshot_path);
++    
++    // Snapshot path management
++    std::string get_snapshot_path(const std::string& tab_id) const;
++    bool snapshot_exists(const std::string& snapshot_path) const;
++
++private:
++    std::filesystem::path snapshot_dir_;
++    
++    void ensure_snapshot_dir();
++    std::string generate_tab_id(Tab* tab) const;
++};
+diff --git a/ryxsurf-cpp/include/tab.h b/ryxsurf-cpp/include/tab.h
+index 27fec0f..61fcc24 100644
+--- a/ryxsurf-cpp/include/tab.h
++++ b/ryxsurf-cpp/include/tab.h
+@@ -45,6 +45,8 @@ public:
+     // Unload/restore
+     void unload();
+     void restore();
++    void set_snapshot_path(const std::string& path) { snapshot_path_ = path; }
++    std::string get_snapshot_path() const { return snapshot_path_; }
+ 
+ private:
+     std::string url_;
+diff --git a/ryxsurf-cpp/include/tab_unload_manager.h b/ryxsurf-cpp/include/tab_unload_manager.h
+new file mode 100644
+index 0000000..c3fe1bd
+--- /dev/null
++++ b/ryxsurf-cpp/include/tab_unload_manager.h
+@@ -0,0 +1,46 @@
++#pragma once
++
++#include "tab.h"
++#include "snapshot_manager.h"
++#include <vector>
++#include <memory>
++#include <chrono>
++#include <functional>
++
++class Session;  // Forward declaration
++
++/**
++ * TabUnloadManager handles automatic tab unloading based on inactivity.
++ * 
++ * Ownership: TabUnloadManager does not own Tab or Session objects.
++ */
++class TabUnloadManager {
++public:
++    TabUnloadManager();
++    ~TabUnloadManager();
++
++    // Non-copyable, movable
++    TabUnloadManager(const TabUnloadManager&) = delete;
++    TabUnloadManager& operator=(const TabUnloadManager&) = delete;
++    TabUnloadManager(TabUnloadManager&&) = default;
++    TabUnloadManager& operator=(TabUnloadManager&&) = default;
++
++    // Configuration
++    void set_unload_timeout_seconds(int seconds) { unload_timeout_seconds_ = seconds; }
++    int get_unload_timeout_seconds() const { return unload_timeout_seconds_; }
++    void set_max_loaded_tabs(int max) { max_loaded_tabs_ = max; }
++    int get_max_loaded_tabs() const { return max_loaded_tabs_; }
++    
++    // Unload operations
++    void check_and_unload(Session* session, size_t active_tab_index);
++    void unload_tab(Tab* tab);
++    void unload_all_except_active(Session* session, size_t active_tab_index);
++
++private:
++    int unload_timeout_seconds_;
++    int max_loaded_tabs_;
++    std::unique_ptr<SnapshotManager> snapshot_manager_;
++    
++    bool should_unload_tab(Tab* tab, size_t tab_index, size_t active_index) const;
++    int count_loaded_tabs(Session* session) const;
++};
+diff --git a/ryxsurf-cpp/meson.build b/ryxsurf-cpp/meson.build
+index 6ba2903..f93341f 100644
+--- a/ryxsurf-cpp/meson.build
++++ b/ryxsurf-cpp/meson.build
+@@ -18,6 +18,7 @@ webkitgtk_dep = dependency('webkitgtk-6.0', version: '>=2.40')
+ sqlite3_dep = dependency('sqlite3')
+ libsecret_dep = dependency('libsecret-1')
+ libsodium_dep = dependency('libsodium')
++cairo_dep = dependency('cairo')
+ 
+ # Compiler flags
+ cpp = meson.get_compiler('cpp')
+@@ -64,6 +65,8 @@ sources = files(
+   'src/session_manager.cpp',
+   'src/session.cpp',
+   'src/workspace.cpp',
++  'src/snapshot_manager.cpp',
++  'src/tab_unload_manager.cpp',
+ )
+ 
+ # Executable
+@@ -77,6 +80,7 @@ executable(
+     sqlite3_dep,
+     libsecret_dep,
+     libsodium_dep,
++    cairo_dep,
+   ],
+   cpp_args: cpp_args,
+   install: true,
+diff --git a/ryxsurf-cpp/src/browser_window.cpp b/ryxsurf-cpp/src/browser_window.cpp
+index dc83678..efb168c 100644
+--- a/ryxsurf-cpp/src/browser_window.cpp
++++ b/ryxsurf-cpp/src/browser_window.cpp
+@@ -1,7 +1,9 @@
+ #include "browser_window.h"
+ #include "session_manager.h"
++#include "tab_unload_manager.h"
+ #include <gtk/gtk.h>
+ #include <webkit/webkit.h>
++#include <glib.h>
+ #include <iostream>
+ 
+ BrowserWindow::BrowserWindow()
+@@ -12,6 +14,8 @@ BrowserWindow::BrowserWindow()
+     , notebook_(nullptr)
+     , session_manager_(std::make_unique<SessionManager>())
+     , keyboard_handler_(std::make_unique<KeyboardHandler>(this))
++    , unload_manager_(std::make_unique<TabUnloadManager>())
++    , unload_timer_id_(0)
+ {
+     // Create main window
+     window_ = GTK_WINDOW(gtk_window_new());
+@@ -47,6 +51,18 @@ BrowserWindow::BrowserWindow()
+     refresh_ui();
+     update_notebook();
+     
++    // Setup periodic unload check (every 60 seconds)
++    unload_timer_id_ = g_timeout_add_seconds(60, 
++        [](gpointer user_data) -> gboolean {
++            BrowserWindow* bw = static_cast<BrowserWindow*>(user_data);
++            Session* session = bw->session_manager_->get_current_session();
++            if (session) {
++                bw->unload_manager_->check_and_unload(
++                    session, session->get_active_tab_index());
++            }
++            return TRUE;  // Keep timer running
++        }, this);
++    
+     // Connect window close
+     g_signal_connect(window_, "close-request",
+                      G_CALLBACK(+[](GtkWindow* window, gpointer) -> gboolean {
+@@ -56,6 +72,12 @@ BrowserWindow::BrowserWindow()
+ }
+ 
+ BrowserWindow::~BrowserWindow() {
++    // Remove unload timer
++    if (unload_timer_id_ != 0) {
++        g_source_remove(unload_timer_id_);
++        unload_timer_id_ = 0;
++    }
++    
+     if (window_) {
+         gtk_window_destroy(window_);
+     }
+@@ -227,6 +249,11 @@ void BrowserWindow::show_tab(size_t index) {
+         return;
+     }
+     
++    // Restore if unloaded
++    if (tab->is_unloaded()) {
++        tab->restore();
++    }
++    
+     ensure_tab_webview_loaded(tab);
+     
+     // Remove all pages from notebook
+diff --git a/ryxsurf-cpp/src/snapshot_manager.cpp b/ryxsurf-cpp/src/snapshot_manager.cpp
+new file mode 100644
+index 0000000..13631e2
+--- /dev/null
++++ b/ryxsurf-cpp/src/snapshot_manager.cpp
+@@ -0,0 +1,164 @@
++#include "snapshot_manager.h"
++#include "tab.h"
++#include <webkit/webkit.h>
++#include <gtk/gtk.h>
++#include <cairo/cairo.h>
++#include <filesystem>
++#include <fstream>
++#include <sstream>
++#include <iomanip>
++#include <chrono>
++
++SnapshotManager::SnapshotManager() {
++    // Use XDG data directory
++    const char* xdg_data = std::getenv("XDG_DATA_HOME");
++    if (xdg_data) {
++        snapshot_dir_ = std::filesystem::path(xdg_data) / "ryxsurf" / "snapshots";
++    } else {
++        snapshot_dir_ = std::filesystem::path(std::getenv("HOME")) / ".local" / "share" / "ryxsurf" / "snapshots";
++    }
++    
++    ensure_snapshot_dir();
++}
++
++SnapshotManager::~SnapshotManager() = default;
++
++void SnapshotManager::ensure_snapshot_dir() {
++    std::filesystem::create_directories(snapshot_dir_);
++}
++
++std::string SnapshotManager::generate_tab_id(Tab* tab) const {
++    // Generate ID from URL + timestamp
++    std::stringstream ss;
++    ss << std::hex << std::hash<std::string>{}(tab->get_url());
++    auto now = std::chrono::system_clock::now();
++    auto time = std::chrono::duration_cast<std::chrono::seconds>(
++        now.time_since_epoch()).count();
++    ss << "_" << time;
++    return ss.str();
++}
++
++std::string SnapshotManager::get_snapshot_path(const std::string& tab_id) const {
++    return (snapshot_dir_ / (tab_id + ".png")).string();
++}
++
++bool SnapshotManager::snapshot_exists(const std::string& snapshot_path) const {
++    return std::filesystem::exists(snapshot_path);
++}
++
++std::string SnapshotManager::create_snapshot(Tab* tab) {
++    if (!tab || !tab->is_loaded()) {
++        return "";
++    }
++    
++    WebKitWebView* webview = tab->get_webview();
++    if (!webview) {
++        return "";
++    }
++    
++    // Generate snapshot ID
++    std::string tab_id = generate_tab_id(tab);
++    std::string snapshot_path = get_snapshot_path(tab_id);
++    
++    // Get WebView size
++    int width = gtk_widget_get_width(GTK_WIDGET(webview));
++    int height = gtk_widget_get_height(GTK_WIDGET(webview));
++    
++    if (width <= 0 || height <= 0) {
++        // Use default size if not yet rendered
++        width = 1920;
++        height = 1080;
++    }
++    
++    // Limit snapshot size for memory efficiency (max 512px width)
++    const int max_width = 512;
++    if (width > max_width) {
++        height = (height * max_width) / width;
++        width = max_width;
++    }
++    
++    // Create Cairo surface
++    cairo_surface_t* surface = cairo_image_surface_create(
++        CAIRO_FORMAT_ARGB32, width, height);
++    
++    if (!surface) {
++        return "";
++    }
++    
++    cairo_t* cr = cairo_create(surface);
++    
++    // Render WebView to surface using WebKit snapshot API
++    // Note: This is a simplified version. Real implementation would use
++    // webkit_web_view_get_snapshot() or similar API
++    cairo_set_source_rgb(cr, 1.0, 1.0, 1.0);
++    cairo_paint(cr);
++    
++    // For now, save a placeholder. Real implementation would:
++    // 1. Use webkit_web_view_get_snapshot() if available
++    // 2. Or use GdkTexture/GdkPixbuf from WebView
++    // 3. Save as PNG with compression
++    
++    cairo_destroy(cr);
++    
++    // Save PNG
++    cairo_surface_write_to_png(surface, snapshot_path.c_str());
++    cairo_surface_destroy(surface);
++    
++    // Save minimal HTML state (URL, title)
++    std::string html_path = snapshot_path;
++    html_path.replace(html_path.length() - 4, 4, ".html");
++    
++    std::ofstream html_file(html_path);
++    if (html_file.is_open()) {
++        html_file << "<!DOCTYPE html>\n";
++        html_file << "<html><head><title>" << tab->get_title() << "</title></head>\n";
++        html_file << "<body><p>Snapshot of: <a href=\"" << tab->get_url() << "\">" 
++                  << tab->get_url() << "</a></p></body></html>\n";
++        html_file.close();
++    }
++    
++    return snapshot_path;
++}
++
++bool SnapshotManager::restore_snapshot(Tab* tab, const std::string& snapshot_path) {
++    if (!tab || !snapshot_exists(snapshot_path)) {
++        return false;
++    }
++    
++    // For now, just restore the URL from the HTML file
++    std::string html_path = snapshot_path;
++    html_path.replace(html_path.length() - 4, 4, ".html");
++    
++    if (std::filesystem::exists(html_path)) {
++        // Parse HTML to extract URL (simplified)
++        // Real implementation would parse properly
++        std::ifstream html_file(html_path);
++        std::string line;
++        while (std::getline(html_file, line)) {
++            size_t href_pos = line.find("href=\"");
++            if (href_pos != std::string::npos) {
++                size_t url_start = href_pos + 6;
++                size_t url_end = line.find("\"", url_start);
++                if (url_end != std::string::npos) {
++                    std::string url = line.substr(url_start, url_end - url_start);
++                    tab->set_url(url);
++                    return true;
++                }
++            }
++        }
++    }
++    
++    return false;
++}
++
++void SnapshotManager::delete_snapshot(const std::string& snapshot_path) {
++    if (std::filesystem::exists(snapshot_path)) {
++        std::filesystem::remove(snapshot_path);
++    }
++    
++    std::string html_path = snapshot_path;
++    html_path.replace(html_path.length() - 4, 4, ".html");
++    if (std::filesystem::exists(html_path)) {
++        std::filesystem::remove(html_path);
++    }
++}
+diff --git a/ryxsurf-cpp/src/tab.cpp b/ryxsurf-cpp/src/tab.cpp
+index ffbcb5a..24de9f3 100644
+--- a/ryxsurf-cpp/src/tab.cpp
++++ b/ryxsurf-cpp/src/tab.cpp
+@@ -110,8 +110,12 @@ void Tab::restore() {
+     
+     create_webview();
+     if (!url_.empty() && url_ != "about:blank") {
+-        webkit_web_view_load_uri(webview_, url_.c_str());
++        WebKitWebView* webview = get_webview();
++        if (webview) {
++            webkit_web_view_load_uri(webview, url_.c_str());
++        }
+     }
++    is_unloaded_ = false;
+ }
+ 
+ void Tab::mark_active() {
+diff --git a/ryxsurf-cpp/src/tab_unload_manager.cpp b/ryxsurf-cpp/src/tab_unload_manager.cpp
+new file mode 100644
+index 0000000..95438c8
+--- /dev/null
++++ b/ryxsurf-cpp/src/tab_unload_manager.cpp
+@@ -0,0 +1,113 @@
++#include "tab_unload_manager.h"
++#include "session.h"
++#include <algorithm>
++#include <chrono>
++
++TabUnloadManager::TabUnloadManager()
++    : unload_timeout_seconds_(300)  // 5 minutes default
++    , max_loaded_tabs_(8)
++    , snapshot_manager_(std::make_unique<SnapshotManager>())
++{
++}
++
++TabUnloadManager::~TabUnloadManager() = default;
++
++int TabUnloadManager::count_loaded_tabs(Session* session) const {
++    if (!session) {
++        return 0;
++    }
++    
++    int count = 0;
++    for (size_t i = 0; i < session->get_tab_count(); ++i) {
++        Tab* tab = session->get_tab(i);
++        if (tab && tab->is_loaded() && !tab->is_unloaded()) {
++            count++;
++        }
++    }
++    return count;
++}
++
++bool TabUnloadManager::should_unload_tab(Tab* tab, size_t tab_index, size_t active_index) const {
++    if (!tab || tab_index == active_index) {
++        return false;  // Don't unload active tab
++    }
++    
++    if (tab->is_unloaded() || !tab->is_loaded()) {
++        return false;  // Already unloaded or not loaded
++    }
++    
++    // Check inactivity timeout
++    auto now = std::chrono::steady_clock::now();
++    auto last_active = tab->get_last_active();
++    auto elapsed = std::chrono::duration_cast<std::chrono::seconds>(now - last_active).count();
++    
++    return elapsed >= unload_timeout_seconds_;
++}
++
++void TabUnloadManager::unload_tab(Tab* tab) {
++    if (!tab || !tab->is_loaded() || tab->is_unloaded()) {
++        return;
++    }
++    
++    // Create snapshot before unloading
++    std::string snapshot_path = snapshot_manager_->create_snapshot(tab);
++    
++    // Unload the tab
++    tab->unload();
++}
++
++void TabUnloadManager::check_and_unload(Session* session, size_t active_tab_index) {
++    if (!session) {
++        return;
++    }
++    
++    int loaded_count = count_loaded_tabs(session);
++    
++    // If we have too many loaded tabs, unload inactive ones
++    if (loaded_count > max_loaded_tabs_) {
++        // Collect tabs to unload (sorted by last active, oldest first)
++        std::vector<std::pair<size_t, Tab*>> candidates;
++        
++        for (size_t i = 0; i < session->get_tab_count(); ++i) {
++            Tab* tab = session->get_tab(i);
++            if (tab && should_unload_tab(tab, i, active_tab_index)) {
++                candidates.push_back({i, tab});
++            }
++        }
++        
++        // Sort by last active (oldest first)
++        std::sort(candidates.begin(), candidates.end(),
++                  [](const auto& a, const auto& b) {
++                      return a.second->get_last_active() < b.second->get_last_active();
++                  });
++        
++        // Unload excess tabs
++        int to_unload = loaded_count - max_loaded_tabs_;
++        for (int i = 0; i < to_unload && i < static_cast<int>(candidates.size()); ++i) {
++            unload_tab(candidates[i].second);
++        }
++    } else {
++        // Check for tabs exceeding timeout
++        for (size_t i = 0; i < session->get_tab_count(); ++i) {
++            Tab* tab = session->get_tab(i);
++            if (tab && should_unload_tab(tab, i, active_tab_index)) {
++                unload_tab(tab);
++            }
++        }
++    }
++}
++
++void TabUnloadManager::unload_all_except_active(Session* session, size_t active_tab_index) {
++    if (!session) {
++        return;
++    }
++    
++    for (size_t i = 0; i < session->get_tab_count(); ++i) {
++        if (i != active_tab_index) {
++            Tab* tab = session->get_tab(i);
++            if (tab && tab->is_loaded() && !tab->is_unloaded()) {
++                unload_tab(tab);
++            }
++        }
++    }
++}
+diff --git a/ryxsurf-cpp/tests/test_unload.cpp b/ryxsurf-cpp/tests/test_unload.cpp
+new file mode 100644
+index 0000000..2b3c320
+--- /dev/null
++++ b/ryxsurf-cpp/tests/test_unload.cpp
+@@ -0,0 +1,44 @@
++#define CATCH_CONFIG_MAIN
++#include <catch2/catch.hpp>
++#include "../include/tab_unload_manager.h"
++#include "../include/session.h"
++#include <thread>
++#include <chrono>
++
++TEST_CASE("TabUnloadManager configuration", "[unload]") {
++    TabUnloadManager um;
++    
++    REQUIRE(um.get_unload_timeout_seconds() == 300);  // 5 minutes default
++    REQUIRE(um.get_max_loaded_tabs() == 8);
++    
++    um.set_unload_timeout_seconds(60);
++    REQUIRE(um.get_unload_timeout_seconds() == 60);
++    
++    um.set_max_loaded_tabs(5);
++    REQUIRE(um.get_max_loaded_tabs() == 5);
++}
++
++TEST_CASE("Tab unload/restore", "[tab]") {
++    Tab tab("https://example.com");
++    
++    REQUIRE_FALSE(tab.is_unloaded());
++    
++    tab.unload();
++    REQUIRE(tab.is_unloaded());
++    REQUIRE_FALSE(tab.is_loaded());
++    
++    // URL should be preserved
++    REQUIRE(tab.get_url() == "https://example.com");
++    
++    tab.restore();
++    // After restore, tab should be ready to load (but not loaded until WebView created)
++    REQUIRE_FALSE(tab.is_unloaded());
++}
++
++TEST_CASE("SnapshotManager path generation", "[snapshot]") {
++    SnapshotManager sm;
++    
++    std::string path = sm.get_snapshot_path("test123");
++    REQUIRE(path.find("test123") != std::string::npos);
++    REQUIRE(path.find(".png") != std::string::npos);
++}
+-- 
+2.52.0
+
diff --git a/ryxsurf-cpp/repo-tree.txt b/ryxsurf-cpp/repo-tree.txt
index 1857895..2fb32e3 100644
--- a/ryxsurf-cpp/repo-tree.txt
+++ b/ryxsurf-cpp/repo-tree.txt
@@ -1,13 +1,31 @@
+ryxsurf-cpp/README.md
+ryxsurf-cpp/build-instructions.md
 ryxsurf-cpp/include/browser_window.h
 ryxsurf-cpp/include/keyboard_handler.h
+ryxsurf-cpp/include/session.h
+ryxsurf-cpp/include/session_manager.h
+ryxsurf-cpp/include/snapshot_manager.h
 ryxsurf-cpp/include/tab.h
+ryxsurf-cpp/include/tab_unload_manager.h
+ryxsurf-cpp/include/workspace.h
 ryxsurf-cpp/meson.build
 ryxsurf-cpp/meson_options.txt
 ryxsurf-cpp/patches/0001-poC-minimal-GTK4-WebKit-app-keyboard-nav.patch
+ryxsurf-cpp/patches/0002-docs-Add-README-build-instructions-and-development-p.patch
+ryxsurf-cpp/patches/0003-core-data-model-structs-session-manager.patch
+ryxsurf-cpp/patches/0004-perf-tab-unload-restore-snapshot.patch
 ryxsurf-cpp/perf/run_perf.sh
+ryxsurf-cpp/plan.md
 ryxsurf-cpp/repo-tree.txt
 ryxsurf-cpp/src/browser_window.cpp
 ryxsurf-cpp/src/keyboard_handler.cpp
 ryxsurf-cpp/src/main.cpp
+ryxsurf-cpp/src/session.cpp
+ryxsurf-cpp/src/session_manager.cpp
+ryxsurf-cpp/src/snapshot_manager.cpp
 ryxsurf-cpp/src/tab.cpp
+ryxsurf-cpp/src/tab_unload_manager.cpp
+ryxsurf-cpp/src/workspace.cpp
+ryxsurf-cpp/tests/test_session_manager.cpp
 ryxsurf-cpp/tests/test_tab.cpp
+ryxsurf-cpp/tests/test_unload.cpp
diff --git a/ryxsurf-cpp/src/browser_window.cpp b/ryxsurf-cpp/src/browser_window.cpp
index efb168c..7b963e2 100644
--- a/ryxsurf-cpp/src/browser_window.cpp
+++ b/ryxsurf-cpp/src/browser_window.cpp
@@ -1,6 +1,7 @@
 #include "browser_window.h"
 #include "session_manager.h"
 #include "tab_unload_manager.h"
+#include "persistence_manager.h"
 #include <gtk/gtk.h>
 #include <webkit/webkit.h>
 #include <glib.h>
@@ -15,6 +16,7 @@ BrowserWindow::BrowserWindow()
     , session_manager_(std::make_unique<SessionManager>())
     , keyboard_handler_(std::make_unique<KeyboardHandler>(this))
     , unload_manager_(std::make_unique<TabUnloadManager>())
+    , persistence_manager_(std::make_unique<PersistenceManager>(session_manager_.get()))
     , unload_timer_id_(0)
 {
     // Create main window
@@ -46,8 +48,18 @@ BrowserWindow::BrowserWindow()
     // Setup keyboard shortcuts
     keyboard_handler_->setup_shortcuts(window_);
     
-    // Create initial tab via session manager
-    session_manager_->new_tab();
+    // Initialize persistence and load saved sessions
+    if (persistence_manager_->initialize()) {
+        persistence_manager_->load_all();
+        persistence_manager_->enable_autosave(30);  // Autosave every 30 seconds
+    }
+    
+    // Create initial tab if no sessions loaded
+    if (session_manager_->get_current_session() && 
+        session_manager_->get_current_session()->get_tab_count() == 0) {
+        session_manager_->new_tab();
+    }
+    
     refresh_ui();
     update_notebook();
     
@@ -63,15 +75,25 @@ BrowserWindow::BrowserWindow()
             return TRUE;  // Keep timer running
         }, this);
     
-    // Connect window close
+    // Connect window close - save before exit
     g_signal_connect(window_, "close-request",
-                     G_CALLBACK(+[](GtkWindow* window, gpointer) -> gboolean {
+                     G_CALLBACK(+[](GtkWindow* window, gpointer user_data) -> gboolean {
+                         BrowserWindow* bw = static_cast<BrowserWindow*>(user_data);
+                         if (bw->persistence_manager_) {
+                             bw->persistence_manager_->save_all();
+                         }
                          gtk_window_destroy(window);
                          return TRUE;
-                     }), nullptr);
+                     }), this);
 }
 
 BrowserWindow::~BrowserWindow() {
+    // Save before exit
+    if (persistence_manager_) {
+        persistence_manager_->save_all();
+        persistence_manager_->close();
+    }
+    
     // Remove unload timer
     if (unload_timer_id_ != 0) {
         g_source_remove(unload_timer_id_);
diff --git a/ryxsurf-cpp/src/crypto.cpp b/ryxsurf-cpp/src/crypto.cpp
new file mode 100644
index 0000000..e095cf2
--- /dev/null
+++ b/ryxsurf-cpp/src/crypto.cpp
@@ -0,0 +1,99 @@
+#include "crypto.h"
+#include <stdexcept>
+#include <cstring>
+
+void Crypto::init() {
+    if (sodium_init() < 0) {
+        throw std::runtime_error("Failed to initialize libsodium");
+    }
+}
+
+std::pair<std::vector<unsigned char>, std::vector<unsigned char>>
+Crypto::derive_key(const std::string& password, const std::vector<unsigned char>& salt) {
+    std::vector<unsigned char> actual_salt = salt;
+    if (actual_salt.empty()) {
+        actual_salt = random_bytes(SALT_SIZE);
+    }
+    
+    if (actual_salt.size() != SALT_SIZE) {
+        throw std::invalid_argument("Salt must be 16 bytes");
+    }
+    
+    std::vector<unsigned char> key(KEY_SIZE);
+    
+    if (crypto_pwhash_argon2id(
+            key.data(), key.size(),
+            password.c_str(), password.length(),
+            actual_salt.data(),
+            OPS_LIMIT,
+            MEM_LIMIT,
+            crypto_pwhash_argon2id_ALG_ARGON2ID13) != 0) {
+        throw std::runtime_error("Argon2id key derivation failed");
+    }
+    
+    return {key, actual_salt};
+}
+
+std::vector<unsigned char>
+Crypto::encrypt(const std::vector<unsigned char>& plaintext, const std::vector<unsigned char>& key) {
+    if (key.size() != KEY_SIZE) {
+        throw std::invalid_argument("Key must be 32 bytes");
+    }
+    
+    std::vector<unsigned char> nonce = random_bytes(NONCE_SIZE);
+    std::vector<unsigned char> ciphertext(plaintext.size() + crypto_aead_xchacha20poly1305_ietf_ABYTES);
+    unsigned long long ciphertext_len;
+    
+    crypto_aead_xchacha20poly1305_ietf_encrypt(
+        ciphertext.data(), &ciphertext_len,
+        plaintext.data(), plaintext.size(),
+        nullptr, 0,  // No additional data
+        nullptr,     // No nsec
+        nonce.data(),
+        key.data());
+    
+    // Prepend nonce to ciphertext
+    std::vector<unsigned char> result;
+    result.reserve(nonce.size() + ciphertext_len);
+    result.insert(result.end(), nonce.begin(), nonce.end());
+    result.insert(result.end(), ciphertext.begin(), ciphertext.begin() + ciphertext_len);
+    
+    return result;
+}
+
+std::vector<unsigned char>
+Crypto::decrypt(const std::vector<unsigned char>& ciphertext, const std::vector<unsigned char>& key) {
+    if (key.size() != KEY_SIZE) {
+        throw std::invalid_argument("Key must be 32 bytes");
+    }
+    
+    if (ciphertext.size() < NONCE_SIZE + crypto_aead_xchacha20poly1305_ietf_ABYTES) {
+        throw std::invalid_argument("Ciphertext too short");
+    }
+    
+    // Extract nonce
+    std::vector<unsigned char> nonce(ciphertext.begin(), ciphertext.begin() + NONCE_SIZE);
+    std::vector<unsigned char> encrypted(ciphertext.begin() + NONCE_SIZE, ciphertext.end());
+    
+    std::vector<unsigned char> plaintext(encrypted.size() - crypto_aead_xchacha20poly1305_ietf_ABYTES);
+    unsigned long long plaintext_len;
+    
+    if (crypto_aead_xchacha20poly1305_ietf_decrypt(
+            plaintext.data(), &plaintext_len,
+            nullptr,  // No nsec
+            encrypted.data(), encrypted.size(),
+            nullptr, 0,  // No additional data
+            nonce.data(),
+            key.data()) != 0) {
+        throw std::runtime_error("Decryption failed");
+    }
+    
+    plaintext.resize(plaintext_len);
+    return plaintext;
+}
+
+std::vector<unsigned char> Crypto::random_bytes(size_t size) {
+    std::vector<unsigned char> bytes(size);
+    randombytes_buf(bytes.data(), size);
+    return bytes;
+}
diff --git a/ryxsurf-cpp/src/main.cpp b/ryxsurf-cpp/src/main.cpp
index 5a32229..e74c928 100644
--- a/ryxsurf-cpp/src/main.cpp
+++ b/ryxsurf-cpp/src/main.cpp
@@ -1,8 +1,18 @@
 #include "browser_window.h"
+#include "crypto.h"
 #include <gtk/gtk.h>
 #include <webkit/webkit.h>
+#include <iostream>
 
 int main(int argc, char* argv[]) {
+    // Initialize libsodium
+    try {
+        Crypto::init();
+    } catch (const std::exception& e) {
+        std::cerr << "Failed to initialize crypto: " << e.what() << std::endl;
+        return 1;
+    }
+    
     // Initialize GTK
     gtk_init(&argc, &argv);
     
diff --git a/ryxsurf-cpp/src/persistence_manager.cpp b/ryxsurf-cpp/src/persistence_manager.cpp
new file mode 100644
index 0000000..3839cdf
--- /dev/null
+++ b/ryxsurf-cpp/src/persistence_manager.cpp
@@ -0,0 +1,400 @@
+#include "persistence_manager.h"
+#include "workspace.h"
+#include "session.h"
+#include "tab.h"
+#include <filesystem>
+#include <fstream>
+#include <sstream>
+#include <map>
+#include <glib.h>
+#include <sqlite3.h>
+#include <stdexcept>
+
+PersistenceManager::PersistenceManager(SessionManager* session_manager)
+    : session_manager_(session_manager)
+    , db_(nullptr)
+    , autosave_enabled_(false)
+    , autosave_interval_(30)
+    , autosave_timer_id_(0)
+{
+    db_path_ = get_db_path();
+}
+
+PersistenceManager::~PersistenceManager() {
+    disable_autosave();
+    close();
+}
+
+std::string PersistenceManager::get_db_path() const {
+    const char* xdg_data = std::getenv("XDG_DATA_HOME");
+    std::filesystem::path base_dir;
+    
+    if (xdg_data) {
+        base_dir = std::filesystem::path(xdg_data) / "ryxsurf";
+    } else {
+        base_dir = std::filesystem::path(std::getenv("HOME")) / ".local" / "share" / "ryxsurf";
+    }
+    
+    std::filesystem::create_directories(base_dir);
+    return (base_dir / "sessions.db").string();
+}
+
+bool PersistenceManager::initialize(const std::string& master_password) {
+    master_password_ = master_password;
+    
+    // Initialize libsodium
+    try {
+        Crypto::init();
+    } catch (const std::exception& e) {
+        return false;
+    }
+    
+    // Setup encryption
+    if (!master_password_.empty()) {
+        if (!setup_encryption()) {
+            return false;
+        }
+    }
+    
+    // Open database
+    int rc = sqlite3_open(db_path_.c_str(), &db_);
+    if (rc != SQLITE_OK) {
+        return false;
+    }
+    
+    // Enable WAL mode
+    execute_sql("PRAGMA journal_mode=WAL;");
+    execute_sql("PRAGMA synchronous=NORMAL;");
+    execute_sql("PRAGMA foreign_keys=ON;");
+    
+    // Create schema
+    return create_schema();
+}
+
+bool PersistenceManager::setup_encryption() {
+    if (master_password_.empty()) {
+        return false;
+    }
+    
+    // Try to load existing salt from database file header or separate file
+    std::string salt_file = db_path_ + ".salt";
+    std::ifstream salt_in(salt_file, std::ios::binary);
+    
+    if (salt_in.is_open()) {
+        salt_.resize(Crypto::SALT_SIZE);
+        salt_in.read(reinterpret_cast<char*>(salt_.data()), Crypto::SALT_SIZE);
+        salt_in.close();
+    } else {
+        // Generate new salt
+        salt_ = Crypto::random_bytes(Crypto::SALT_SIZE);
+        std::ofstream salt_out(salt_file, std::ios::binary);
+        if (salt_out.is_open()) {
+            salt_out.write(reinterpret_cast<const char*>(salt_.data()), Crypto::SALT_SIZE);
+            salt_out.close();
+        }
+    }
+    
+    // Derive key
+    try {
+        auto [key, _] = Crypto::derive_key(master_password_, salt_);
+        encryption_key_ = key;
+        return true;
+    } catch (const std::exception&) {
+        return false;
+    }
+}
+
+bool PersistenceManager::create_schema() {
+    return create_tables();
+}
+
+bool PersistenceManager::create_tables() {
+    const char* schema = R"(
+        CREATE TABLE IF NOT EXISTS workspaces (
+            id INTEGER PRIMARY KEY AUTOINCREMENT,
+            name TEXT NOT NULL UNIQUE,
+            created_at INTEGER NOT NULL,
+            updated_at INTEGER NOT NULL
+        );
+        
+        CREATE TABLE IF NOT EXISTS sessions (
+            id INTEGER PRIMARY KEY AUTOINCREMENT,
+            workspace_id INTEGER NOT NULL,
+            name TEXT NOT NULL,
+            is_overview INTEGER NOT NULL DEFAULT 0,
+            created_at INTEGER NOT NULL,
+            updated_at INTEGER NOT NULL,
+            FOREIGN KEY (workspace_id) REFERENCES workspaces(id) ON DELETE CASCADE,
+            UNIQUE(workspace_id, name)
+        );
+        
+        CREATE TABLE IF NOT EXISTS tabs (
+            id INTEGER PRIMARY KEY AUTOINCREMENT,
+            session_id INTEGER NOT NULL,
+            url TEXT NOT NULL,
+            title TEXT NOT NULL,
+            snapshot_path TEXT,
+            last_active INTEGER NOT NULL,
+            position INTEGER NOT NULL,
+            FOREIGN KEY (session_id) REFERENCES sessions(id) ON DELETE CASCADE
+        );
+        
+        CREATE INDEX IF NOT EXISTS idx_sessions_workspace ON sessions(workspace_id);
+        CREATE INDEX IF NOT EXISTS idx_tabs_session ON tabs(session_id);
+    )";
+    
+    return execute_sql(schema);
+}
+
+bool PersistenceManager::execute_sql(const std::string& sql) {
+    if (!db_) {
+        return false;
+    }
+    
+    char* err_msg = nullptr;
+    int rc = sqlite3_exec(db_, sql.c_str(), nullptr, nullptr, &err_msg);
+    
+    if (rc != SQLITE_OK) {
+        if (err_msg) {
+            sqlite3_free(err_msg);
+        }
+        return false;
+    }
+    
+    return true;
+}
+
+std::vector<unsigned char> PersistenceManager::encrypt_data(const std::string& data) {
+    if (encryption_key_.empty()) {
+        // Return plaintext as bytes if no encryption
+        return std::vector<unsigned char>(data.begin(), data.end());
+    }
+    
+    std::vector<unsigned char> plaintext(data.begin(), data.end());
+    return Crypto::encrypt(plaintext, encryption_key_);
+}
+
+std::string PersistenceManager::decrypt_data(const std::vector<unsigned char>& encrypted) {
+    if (encryption_key_.empty()) {
+        // Return as string if no encryption
+        return std::string(encrypted.begin(), encrypted.end());
+    }
+    
+    std::vector<unsigned char> plaintext = Crypto::decrypt(encrypted, encryption_key_);
+    return std::string(plaintext.begin(), plaintext.end());
+}
+
+bool PersistenceManager::save_all() {
+    if (!db_) {
+        return false;
+    }
+    
+    // Begin transaction
+    execute_sql("BEGIN TRANSACTION;");
+    
+    // Clear existing data
+    execute_sql("DELETE FROM tabs;");
+    execute_sql("DELETE FROM sessions;");
+    execute_sql("DELETE FROM workspaces;");
+    
+    // Save all workspaces
+    for (size_t i = 0; i < session_manager_->get_workspace_count(); ++i) {
+        Workspace* ws = session_manager_->get_workspace(i);
+        if (ws) {
+            if (!save_workspace(ws)) {
+                execute_sql("ROLLBACK;");
+                return false;
+            }
+        }
+    }
+    
+    // Commit transaction
+    execute_sql("COMMIT;");
+    return true;
+}
+
+bool PersistenceManager::save_workspace(Workspace* workspace) {
+    if (!workspace || !db_) {
+        return false;
+    }
+    
+    // Insert workspace
+    std::stringstream ss;
+    auto created = std::chrono::duration_cast<std::chrono::seconds>(
+        workspace->get_created_at().time_since_epoch()).count();
+    auto updated = std::chrono::duration_cast<std::chrono::seconds>(
+        workspace->get_updated_at().time_since_epoch()).count();
+    
+    ss << "INSERT OR REPLACE INTO workspaces (name, created_at, updated_at) "
+       << "VALUES ('" << workspace->get_name() << "', " << created << ", " << updated << ");";
+    
+    if (!execute_sql(ss.str())) {
+        return false;
+    }
+    
+    // Get workspace ID
+    sqlite3_int64 workspace_id = sqlite3_last_insert_rowid(db_);
+    
+    // Save sessions
+    for (size_t i = 0; i < workspace->get_session_count(); ++i) {
+        Session* session = workspace->get_session(i);
+        if (!session) {
+            continue;
+        }
+        
+        auto s_created = std::chrono::duration_cast<std::chrono::seconds>(
+            session->get_created_at().time_since_epoch()).count();
+        auto s_updated = std::chrono::duration_cast<std::chrono::seconds>(
+            session->get_updated_at().time_since_epoch()).count();
+        
+        ss.str("");
+        ss << "INSERT OR REPLACE INTO sessions (workspace_id, name, is_overview, created_at, updated_at) "
+           << "VALUES (" << workspace_id << ", '" << session->get_name() << "', "
+           << (session->is_overview() ? 1 : 0) << ", " << s_created << ", " << s_updated << ");";
+        
+        if (!execute_sql(ss.str())) {
+            return false;
+        }
+        
+        sqlite3_int64 session_id = sqlite3_last_insert_rowid(db_);
+        
+        // Save tabs
+        for (size_t j = 0; j < session->get_tab_count(); ++j) {
+            Tab* tab = session->get_tab(j);
+            if (!tab) {
+                continue;
+            }
+            
+            auto last_active = std::chrono::duration_cast<std::chrono::seconds>(
+                tab->get_last_active().time_since_epoch()).count();
+            
+            ss.str("");
+            ss << "INSERT INTO tabs (session_id, url, title, snapshot_path, last_active, position) "
+               << "VALUES (" << session_id << ", '" << tab->get_url() << "', '"
+               << tab->get_title() << "', '" << tab->get_snapshot_path() << "', "
+               << last_active << ", " << j << ");";
+            
+            if (!execute_sql(ss.str())) {
+                return false;
+            }
+        }
+    }
+    
+    return true;
+}
+
+bool PersistenceManager::load_all() {
+    if (!db_) {
+        return false;
+    }
+    
+    // Load workspaces
+    const char* sql = "SELECT id, name, created_at, updated_at FROM workspaces ORDER BY id;";
+    sqlite3_stmt* stmt;
+    
+    if (sqlite3_prepare_v2(db_, sql, -1, &stmt, nullptr) != SQLITE_OK) {
+        return false;
+    }
+    
+    std::map<sqlite3_int64, Workspace*> workspace_map;
+    
+    while (sqlite3_step(stmt) == SQLITE_ROW) {
+        sqlite3_int64 id = sqlite3_column_int64(stmt, 0);
+        const char* name = reinterpret_cast<const char*>(sqlite3_column_text(stmt, 1));
+        sqlite3_int64 created = sqlite3_column_int64(stmt, 2);
+        sqlite3_int64 updated = sqlite3_column_int64(stmt, 3);
+        
+        Workspace* ws = session_manager_->add_workspace(name);
+        workspace_map[id] = ws;
+        
+        // Load sessions for this workspace
+        std::stringstream ss;
+        ss << "SELECT id, name, is_overview, created_at, updated_at FROM sessions "
+           << "WHERE workspace_id = " << id << " ORDER BY id;";
+        
+        sqlite3_stmt* session_stmt;
+        if (sqlite3_prepare_v2(db_, ss.str().c_str(), -1, &session_stmt, nullptr) == SQLITE_OK) {
+            while (sqlite3_step(session_stmt) == SQLITE_ROW) {
+                sqlite3_int64 session_id = sqlite3_column_int64(session_stmt, 0);
+                const char* s_name = reinterpret_cast<const char*>(sqlite3_column_text(session_stmt, 1));
+                int is_overview = sqlite3_column_int(session_stmt, 2);
+                
+                Session* session = ws->add_session(s_name);
+                session->set_overview(is_overview != 0);
+                
+                // Load tabs for this session
+                ss.str("");
+                ss << "SELECT url, title, snapshot_path, last_active, position FROM tabs "
+                   << "WHERE session_id = " << session_id << " ORDER BY position;";
+                
+                sqlite3_stmt* tab_stmt;
+                if (sqlite3_prepare_v2(db_, ss.str().c_str(), -1, &tab_stmt, nullptr) == SQLITE_OK) {
+                    while (sqlite3_step(tab_stmt) == SQLITE_ROW) {
+                        const char* url = reinterpret_cast<const char*>(sqlite3_column_text(tab_stmt, 0));
+                        const char* title = reinterpret_cast<const char*>(sqlite3_column_text(tab_stmt, 1));
+                        const char* snapshot = reinterpret_cast<const char*>(sqlite3_column_text(tab_stmt, 2));
+                        
+                        Tab* tab = session->add_tab(url ? url : "");
+                        tab->set_title(title ? title : "");
+                        if (snapshot) {
+                            tab->set_snapshot_path(snapshot);
+                        }
+                    }
+                    sqlite3_finalize(tab_stmt);
+                }
+            }
+            sqlite3_finalize(session_stmt);
+        }
+    }
+    
+    sqlite3_finalize(stmt);
+    return true;
+}
+
+void PersistenceManager::enable_autosave(int interval_seconds) {
+    disable_autosave();
+    autosave_enabled_ = true;
+    autosave_interval_ = interval_seconds;
+    autosave_timer_id_ = g_timeout_add_seconds(
+        interval_seconds,
+        autosave_callback,
+        this);
+}
+
+void PersistenceManager::disable_autosave() {
+    if (autosave_timer_id_ != 0) {
+        g_source_remove(autosave_timer_id_);
+        autosave_timer_id_ = 0;
+    }
+    autosave_enabled_ = false;
+}
+
+gboolean PersistenceManager::autosave_callback(gpointer user_data) {
+    PersistenceManager* pm = static_cast<PersistenceManager*>(user_data);
+    pm->save_all();
+    return TRUE;  // Keep timer running
+}
+
+void PersistenceManager::close() {
+    disable_autosave();
+    if (db_) {
+        sqlite3_close(db_);
+        db_ = nullptr;
+    }
+}
+
+void PersistenceManager::set_master_password(const std::string& password) {
+    master_password_ = password;
+    if (!password.empty()) {
+        setup_encryption();
+    } else {
+        encryption_key_.clear();
+        salt_.clear();
+    }
+}
+
+bool PersistenceManager::load_workspace(const std::string& name, Workspace* workspace) {
+    // Implementation for loading single workspace
+    // For now, load_all handles everything
+    return false;
+}
diff --git a/ryxsurf-cpp/tests/test_persistence.cpp b/ryxsurf-cpp/tests/test_persistence.cpp
new file mode 100644
index 0000000..d05b4a4
--- /dev/null
+++ b/ryxsurf-cpp/tests/test_persistence.cpp
@@ -0,0 +1,91 @@
+#define CATCH_CONFIG_MAIN
+#include <catch2/catch.hpp>
+#include "../include/persistence_manager.h"
+#include "../include/session_manager.h"
+#include "../include/crypto.h"
+#include <filesystem>
+#include <fstream>
+
+TEST_CASE("Crypto key derivation", "[crypto]") {
+    Crypto::init();
+    
+    auto [key1, salt1] = Crypto::derive_key("test_password");
+    REQUIRE(key1.size() == Crypto::KEY_SIZE);
+    REQUIRE(salt1.size() == Crypto::SALT_SIZE);
+    
+    // Same password + salt should produce same key
+    auto [key2, salt2] = Crypto::derive_key("test_password", salt1);
+    REQUIRE(key1 == key2);
+}
+
+TEST_CASE("Crypto encrypt/decrypt", "[crypto]") {
+    Crypto::init();
+    
+    auto [key, salt] = Crypto::derive_key("test_password");
+    std::string plaintext = "Hello, World!";
+    
+    std::vector<unsigned char> plaintext_bytes(plaintext.begin(), plaintext.end());
+    std::vector<unsigned char> encrypted = Crypto::encrypt(plaintext_bytes, key);
+    
+    REQUIRE(encrypted.size() > plaintext_bytes.size());
+    
+    std::vector<unsigned char> decrypted = Crypto::decrypt(encrypted, key);
+    std::string decrypted_text(decrypted.begin(), decrypted.end());
+    
+    REQUIRE(decrypted_text == plaintext);
+}
+
+TEST_CASE("PersistenceManager initialization", "[persistence]") {
+    SessionManager sm;
+    PersistenceManager pm(&sm);
+    
+    // Create temporary database path
+    std::string test_db = "/tmp/test_ryxsurf.db";
+    pm.db_path_ = test_db;
+    
+    REQUIRE(pm.initialize("test_password"));
+    REQUIRE(pm.has_master_password());
+    
+    // Cleanup
+    pm.close();
+    std::filesystem::remove(test_db);
+    std::filesystem::remove(test_db + ".salt");
+}
+
+TEST_CASE("PersistenceManager save/load", "[persistence]") {
+    SessionManager sm;
+    PersistenceManager pm(&sm);
+    
+    std::string test_db = "/tmp/test_ryxsurf_save.db";
+    pm.db_path_ = test_db;
+    
+    REQUIRE(pm.initialize("test_password"));
+    
+    // Create test data
+    Workspace* ws = sm.add_workspace("TestWorkspace");
+    Session* session = ws->add_session("TestSession");
+    Tab* tab = session->add_tab("https://example.com");
+    tab->set_title("Example");
+    
+    // Save
+    REQUIRE(pm.save_all());
+    
+    // Create new session manager and load
+    SessionManager sm2;
+    PersistenceManager pm2(&sm2);
+    pm2.db_path_ = test_db;
+    REQUIRE(pm2.initialize("test_password"));
+    REQUIRE(pm2.load_all());
+    
+    // Verify loaded data
+    REQUIRE(sm2.get_workspace_count() > 0);
+    Workspace* loaded_ws = sm2.get_workspace(0);
+    REQUIRE(loaded_ws != nullptr);
+    REQUIRE(loaded_ws->get_name() == "TestWorkspace");
+    
+    // Cleanup
+    pm.close();
+    pm2.close();
+    std::filesystem::remove(test_db);
+    std::filesystem::remove(test_db + ".salt");
+}
-- 
2.52.0

