From 7d081eead96e42fd3150cd2d5a4686d15105243a Mon Sep 17 00:00:00 2001
From: Tobito320 <ahmedhdplay12345@gmail.com>
Date: Thu, 11 Dec 2025 19:39:06 +0100
Subject: [PATCH 1/4] poC: minimal GTK4 WebKit app + keyboard nav

Implemented proof-of-concept minimal browser:
- GTK4 window with tab bar, address bar, notebook
- WebKit6 integration with lazy WebView loading
- Keyboard shortcuts: Ctrl+T (new tab), Ctrl+W (close), Ctrl+Arrow keys (navigate)
- Tab management with lazy instantiation (WebView created only when focused)
- Basic UI updates and signal handling
- Meson build system configuration
- Unit tests skeleton (Catch2)
- Performance test script (measures cold start and RSS)

This PoC demonstrates core architecture and keyboard-first navigation.
Session persistence, password manager, and other features are planned
for future milestones.
---
 ryxsurf-cpp/include/browser_window.h   |  62 ++++++
 ryxsurf-cpp/include/keyboard_handler.h |  31 +++
 ryxsurf-cpp/include/tab.h              |  57 ++++++
 ryxsurf-cpp/meson.build                |  98 +++++++++
 ryxsurf-cpp/meson_options.txt          |   2 +
 ryxsurf-cpp/perf/run_perf.sh           |  98 +++++++++
 ryxsurf-cpp/src/browser_window.cpp     | 265 +++++++++++++++++++++++++
 ryxsurf-cpp/src/keyboard_handler.cpp   |  90 +++++++++
 ryxsurf-cpp/src/main.cpp               |  22 ++
 ryxsurf-cpp/src/tab.cpp                | 119 +++++++++++
 ryxsurf-cpp/tests/test_tab.cpp         |  48 +++++
 11 files changed, 892 insertions(+)
 create mode 100644 ryxsurf-cpp/include/browser_window.h
 create mode 100644 ryxsurf-cpp/include/keyboard_handler.h
 create mode 100644 ryxsurf-cpp/include/tab.h
 create mode 100644 ryxsurf-cpp/meson.build
 create mode 100644 ryxsurf-cpp/meson_options.txt
 create mode 100755 ryxsurf-cpp/perf/run_perf.sh
 create mode 100644 ryxsurf-cpp/src/browser_window.cpp
 create mode 100644 ryxsurf-cpp/src/keyboard_handler.cpp
 create mode 100644 ryxsurf-cpp/src/main.cpp
 create mode 100644 ryxsurf-cpp/src/tab.cpp
 create mode 100644 ryxsurf-cpp/tests/test_tab.cpp

diff --git a/ryxsurf-cpp/include/browser_window.h b/ryxsurf-cpp/include/browser_window.h
new file mode 100644
index 0000000..d9a78e2
--- /dev/null
+++ b/ryxsurf-cpp/include/browser_window.h
@@ -0,0 +1,62 @@
+#pragma once
+
+#include <gtk/gtk.h>
+#include <webkit/webkit.h>
+#include <vector>
+#include <memory>
+#include "tab.h"
+#include "keyboard_handler.h"
+
+/**
+ * BrowserWindow is the main GTK4 window containing the browser UI.
+ * 
+ * Ownership: BrowserWindow owns Tab objects and KeyboardHandler.
+ * The window manages the visual representation of tabs.
+ */
+class BrowserWindow {
+public:
+    BrowserWindow();
+    ~BrowserWindow();
+
+    // Non-copyable, movable
+    BrowserWindow(const BrowserWindow&) = delete;
+    BrowserWindow& operator=(const BrowserWindow&) = delete;
+    BrowserWindow(BrowserWindow&&) = default;
+    BrowserWindow& operator=(BrowserWindow&&) = default;
+
+    void show();
+    GtkWindow* get_window() { return window_; }
+
+    // Tab operations (called by KeyboardHandler)
+    void new_tab(const std::string& url = "");
+    void close_current_tab();
+    void next_tab();
+    void previous_tab();
+    void focus_address_bar();
+
+private:
+    GtkWindow* window_;
+    GtkBox* main_box_;
+    GtkBox* tab_bar_;
+    GtkEntry* address_bar_;
+    GtkNotebook* notebook_;
+    
+    std::vector<std::unique_ptr<Tab>> tabs_;
+    size_t active_tab_index_;
+    
+    std::unique_ptr<KeyboardHandler> keyboard_handler_;
+    
+    // UI update methods
+    void update_tab_bar();
+    void update_address_bar();
+    void update_notebook();
+    void refresh_ui();
+    
+    // Signal handlers
+    static void on_address_bar_activated(GtkEntry* entry, gpointer user_data);
+    static void on_tab_close_clicked(GtkButton* button, gpointer user_data);
+    
+    // Tab webview management
+    void ensure_tab_webview_loaded(Tab* tab);
+    void show_tab(size_t index);
+};
diff --git a/ryxsurf-cpp/include/keyboard_handler.h b/ryxsurf-cpp/include/keyboard_handler.h
new file mode 100644
index 0000000..9c7c013
--- /dev/null
+++ b/ryxsurf-cpp/include/keyboard_handler.h
@@ -0,0 +1,31 @@
+#pragma once
+
+#include <gtk/gtk.h>
+#include <gdk/gdkkeysyms.h>
+
+class BrowserWindow;  // Forward declaration
+
+/**
+ * KeyboardHandler manages global keyboard shortcuts for the browser.
+ * 
+ * All shortcuts are handled at the application level for immediate
+ * non-blocking response.
+ */
+class KeyboardHandler {
+public:
+    KeyboardHandler(BrowserWindow* browser_window);
+    ~KeyboardHandler();
+
+    // Setup keyboard shortcuts on a window
+    void setup_shortcuts(GtkWindow* window);
+
+private:
+    BrowserWindow* browser_window_;
+    
+    // Shortcut handlers
+    static gboolean on_key_pressed(GtkEventControllerKey* controller,
+                                   guint keyval,
+                                   guint keycode,
+                                   GdkModifierType state,
+                                   gpointer user_data);
+};
diff --git a/ryxsurf-cpp/include/tab.h b/ryxsurf-cpp/include/tab.h
new file mode 100644
index 0000000..27fec0f
--- /dev/null
+++ b/ryxsurf-cpp/include/tab.h
@@ -0,0 +1,57 @@
+#pragma once
+
+#include <webkit/webkit.h>
+#include <gtk/gtk.h>
+#include <string>
+#include <memory>
+#include <chrono>
+
+/**
+ * Tab represents a single browser tab with lazy WebView loading.
+ * 
+ * Ownership: Tab owns its WebKitWebView when loaded, but the view
+ * is managed by GTK container hierarchy. Tab metadata persists even
+ * when webview is unloaded.
+ */
+class Tab {
+public:
+    Tab(const std::string& url = "about:blank");
+    ~Tab();
+
+    // Non-copyable, movable
+    Tab(const Tab&) = delete;
+    Tab& operator=(const Tab&) = delete;
+    Tab(Tab&&) = default;
+    Tab& operator=(Tab&&) = default;
+
+    // WebView management
+    WebKitWebView* get_webview();
+    GtkWidget* get_container();
+    void create_webview();
+    void destroy_webview();
+    bool is_loaded() const { return webview_ != nullptr; }
+    bool is_unloaded() const { return is_unloaded_; }
+
+    // Metadata
+    std::string get_url() const { return url_; }
+    std::string get_title() const { return title_; }
+    void set_url(const std::string& url) { url_ = url; }
+    void set_title(const std::string& title) { title_ = title; }
+    
+    // Activity tracking
+    void mark_active();
+    std::chrono::steady_clock::time_point get_last_active() const { return last_active_; }
+
+    // Unload/restore
+    void unload();
+    void restore();
+
+private:
+    std::string url_;
+    std::string title_;
+    WebKitWebView* webview_;
+    GtkWidget* container_;
+    std::chrono::steady_clock::time_point last_active_;
+    bool is_unloaded_;
+    std::string snapshot_path_;
+};
diff --git a/ryxsurf-cpp/meson.build b/ryxsurf-cpp/meson.build
new file mode 100644
index 0000000..acc3ebb
--- /dev/null
+++ b/ryxsurf-cpp/meson.build
@@ -0,0 +1,98 @@
+project(
+  'ryxsurf-cpp',
+  'cpp',
+  version: '0.1.0',
+  license: 'MIT',
+  default_options: [
+    'cpp_std=c++17',
+    'warning_level=3',
+    'werror=false',
+    'optimization=3',
+    'b_lto=true',
+  ],
+)
+
+# Dependencies
+gtk4_dep = dependency('gtk4', version: '>=4.0')
+webkitgtk_dep = dependency('webkitgtk-6.0', version: '>=2.40')
+sqlite3_dep = dependency('sqlite3')
+libsecret_dep = dependency('libsecret-1')
+libsodium_dep = dependency('libsodium')
+
+# Compiler flags
+cpp = meson.get_compiler('cpp')
+cpp_args = []
+
+# Release flags
+if get_option('buildtype') == 'release'
+  cpp_args += [
+    '-O3',
+    '-march=native',
+    '-DNDEBUG',
+    '-flto',
+  ]
+endif
+
+# Debug flags
+if get_option('buildtype') == 'debug'
+  cpp_args += [
+    '-g',
+    '-O0',
+  ]
+endif
+
+# Sanitizers (optional)
+if get_option('sanitize') != 'none'
+  if get_option('sanitize') == 'address'
+    cpp_args += ['-fsanitize=address', '-fno-omit-frame-pointer']
+  elif get_option('sanitize') == 'thread'
+    cpp_args += ['-fsanitize=thread']
+  elif get_option('sanitize') == 'undefined'
+    cpp_args += ['-fsanitize=undefined']
+  endif
+endif
+
+# Include directories
+inc_dir = include_directories('include')
+
+# Source files
+sources = files(
+  'src/main.cpp',
+  'src/browser_window.cpp',
+  'src/tab.cpp',
+  'src/keyboard_handler.cpp',
+)
+
+# Executable
+executable(
+  'ryxsurf',
+  sources,
+  include_directories: inc_dir,
+  dependencies: [
+    gtk4_dep,
+    webkitgtk_dep,
+    sqlite3_dep,
+    libsecret_dep,
+    libsodium_dep,
+  ],
+  cpp_args: cpp_args,
+  install: true,
+)
+
+# Tests
+if get_option('tests')
+  catch2_dep = dependency('catch2', required: false)
+  if catch2_dep.found()
+    test_sources = files(
+      'tests/test_tab.cpp',
+    )
+    test_exe = executable(
+      'test_ryxsurf',
+      test_sources,
+      include_directories: inc_dir,
+      dependencies: [catch2_dep],
+      cpp_args: cpp_args,
+    )
+    test('Tab Tests', test_exe)
+  endif
+endif
diff --git a/ryxsurf-cpp/meson_options.txt b/ryxsurf-cpp/meson_options.txt
new file mode 100644
index 0000000..421cbff
--- /dev/null
+++ b/ryxsurf-cpp/meson_options.txt
@@ -0,0 +1,2 @@
+option('tests', type: 'boolean', value: true, description: 'Build tests')
+option('sanitize', type: 'combo', choices: ['none', 'address', 'thread', 'undefined'], value: 'none', description: 'Enable sanitizers')
diff --git a/ryxsurf-cpp/perf/run_perf.sh b/ryxsurf-cpp/perf/run_perf.sh
new file mode 100755
index 0000000..ed2f944
--- /dev/null
+++ b/ryxsurf-cpp/perf/run_perf.sh
@@ -0,0 +1,98 @@
+#!/bin/bash
+# Performance testing script for ryxsurf-cpp
+# Measures cold start time and memory usage
+
+set -e
+
+SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
+PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
+BUILD_DIR="$PROJECT_ROOT/build"
+BINARY="$BUILD_DIR/ryxsurf"
+
+# Colors
+RED='\033[0;31m'
+GREEN='\033[0;32m'
+YELLOW='\033[1;33m'
+NC='\033[0m'
+
+# Check if binary exists
+if [ ! -f "$BINARY" ]; then
+    echo -e "${RED}Error: Binary not found at $BINARY${NC}"
+    echo "Please build the project first: meson setup build && meson compile -C build"
+    exit 1
+fi
+
+# Create results directory
+RESULTS_DIR="$PROJECT_ROOT/perf/results"
+mkdir -p "$RESULTS_DIR"
+TIMESTAMP=$(date +%Y%m%d_%H%M%S)
+RESULT_FILE="$RESULTS_DIR/perf_${TIMESTAMP}.txt"
+
+echo "=== RyxSurf C++ Performance Test ===" | tee "$RESULT_FILE"
+echo "Timestamp: $(date)" | tee -a "$RESULT_FILE"
+echo "System: $(uname -a)" | tee -a "$RESULT_FILE"
+echo "CPU: $(lscpu | grep 'Model name' | cut -d: -f2 | xargs)" | tee -a "$RESULT_FILE"
+echo "Memory: $(free -h | grep '^Mem:' | awk '{print $2}')" | tee -a "$RESULT_FILE"
+echo "" | tee -a "$RESULT_FILE"
+
+# Test 1: Cold Start Time
+echo -e "${YELLOW}Test 1: Cold Start Time${NC}" | tee -a "$RESULT_FILE"
+echo "Measuring time to first window display..." | tee -a "$RESULT_FILE"
+
+START_TIME=$(date +%s%N)
+timeout 5s "$BINARY" 2>&1 > /dev/null &
+BROWSER_PID=$!
+
+# Wait briefly for window
+sleep 0.5
+kill $BROWSER_PID 2>/dev/null || true
+wait $BROWSER_PID 2>/dev/null || true
+
+END_TIME=$(date +%s%N)
+ELAPSED_MS=$(( (END_TIME - START_TIME) / 1000000 ))
+
+echo "COLD_START_MS=${ELAPSED_MS}" | tee -a "$RESULT_FILE"
+echo "Cold start time: ${ELAPSED_MS}ms" | tee -a "$RESULT_FILE"
+echo "Target: < 500ms" | tee -a "$RESULT_FILE"
+
+if [ $ELAPSED_MS -lt 500 ]; then
+    echo -e "${GREEN}✓ PASS${NC}" | tee -a "$RESULT_FILE"
+else
+    echo -e "${RED}✗ FAIL (exceeds target)${NC}" | tee -a "$RESULT_FILE"
+fi
+echo "" | tee -a "$RESULT_FILE"
+
+# Test 2: Memory Usage (Idle)
+echo -e "${YELLOW}Test 2: Idle Memory Usage${NC}" | tee -a "$RESULT_FILE"
+echo "Measuring RSS with 1 loaded tab..." | tee -a "$RESULT_FILE"
+
+"$BINARY" &
+BROWSER_PID=$!
+sleep 2
+
+# Get RSS (Resident Set Size) in KB
+RSS_KB=$(ps -o rss= -p $BROWSER_PID 2>/dev/null || echo "0")
+RSS_MB=$((RSS_KB / 1024))
+
+kill $BROWSER_PID 2>/dev/null || true
+wait $BROWSER_PID 2>/dev/null || true
+
+echo "IDLE_RSS_MB=${RSS_MB}" | tee -a "$RESULT_FILE"
+echo "Idle RSS: ${RSS_MB}MB" | tee -a "$RESULT_FILE"
+echo "Target: < 200MB (with 3 unloaded + 1 loaded tab)" | tee -a "$RESULT_FILE"
+
+if [ $RSS_MB -lt 200 ]; then
+    echo -e "${GREEN}✓ PASS${NC}" | tee -a "$RESULT_FILE"
+else
+    echo -e "${RED}✗ FAIL (exceeds target)${NC}" | tee -a "$RESULT_FILE"
+fi
+echo "" | tee -a "$RESULT_FILE"
+
+# Summary
+echo "=== Summary ===" | tee -a "$RESULT_FILE"
+echo "COLD_START_MS=${ELAPSED_MS}" | tee -a "$RESULT_FILE"
+echo "IDLE_RSS_MB=${RSS_MB}" | tee -a "$RESULT_FILE"
+echo "Results saved to: $RESULT_FILE" | tee -a "$RESULT_FILE"
+
+# Display results
+cat "$RESULT_FILE"
diff --git a/ryxsurf-cpp/src/browser_window.cpp b/ryxsurf-cpp/src/browser_window.cpp
new file mode 100644
index 0000000..cbf9d6f
--- /dev/null
+++ b/ryxsurf-cpp/src/browser_window.cpp
@@ -0,0 +1,265 @@
+#include "browser_window.h"
+#include <gtk/gtk.h>
+#include <webkit/webkit.h>
+#include <iostream>
+
+BrowserWindow::BrowserWindow()
+    : window_(nullptr)
+    , main_box_(nullptr)
+    , tab_bar_(nullptr)
+    , address_bar_(nullptr)
+    , notebook_(nullptr)
+    , active_tab_index_(0)
+    , keyboard_handler_(std::make_unique<KeyboardHandler>(this))
+{
+    // Create main window
+    window_ = GTK_WINDOW(gtk_window_new());
+    gtk_window_set_title(window_, "RyxSurf");
+    gtk_window_set_default_size(window_, 1200, 800);
+    
+    // Main vertical box
+    main_box_ = GTK_BOX(gtk_box_new(GTK_ORIENTATION_VERTICAL, 0));
+    gtk_window_set_child(window_, GTK_WIDGET(main_box_));
+    
+    // Tab bar (horizontal, compact)
+    tab_bar_ = GTK_BOX(gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 4));
+    gtk_widget_add_css_class(GTK_WIDGET(tab_bar_), "tab-bar");
+    gtk_box_append(main_box_, GTK_WIDGET(tab_bar_));
+    
+    // Address bar
+    address_bar_ = GTK_ENTRY(gtk_entry_new());
+    gtk_entry_set_placeholder_text(address_bar_, "Enter URL or search...");
+    g_signal_connect(address_bar_, "activate",
+                     G_CALLBACK(on_address_bar_activated), this);
+    gtk_box_append(main_box_, GTK_WIDGET(address_bar_));
+    
+    // Notebook for tab webviews
+    notebook_ = GTK_NOTEBOOK(gtk_notebook_new());
+    gtk_notebook_set_show_tabs(notebook_, FALSE);
+    gtk_box_append(main_box_, GTK_WIDGET(notebook_));
+    
+    // Setup keyboard shortcuts
+    keyboard_handler_->setup_shortcuts(window_);
+    
+    // Create initial tab
+    new_tab();
+    
+    // Connect window close
+    g_signal_connect(window_, "close-request",
+                     G_CALLBACK(+[](GtkWindow* window, gpointer) -> gboolean {
+                         gtk_window_destroy(window);
+                         return TRUE;
+                     }), nullptr);
+}
+
+BrowserWindow::~BrowserWindow() {
+    if (window_) {
+        gtk_window_destroy(window_);
+    }
+}
+
+void BrowserWindow::show() {
+    gtk_window_present(window_);
+}
+
+void BrowserWindow::new_tab(const std::string& url) {
+    auto tab = std::make_unique<Tab>(url.empty() ? "about:blank" : url);
+    Tab* tab_ptr = tab.get();
+    tabs_.push_back(std::move(tab));
+    active_tab_index_ = tabs_.size() - 1;
+    
+    refresh_ui();
+    show_tab(active_tab_index_);
+    
+    // Load URL if provided
+    if (!url.empty()) {
+        ensure_tab_webview_loaded(tab_ptr);
+        webkit_web_view_load_uri(tab_ptr->get_webview(), url.c_str());
+    }
+}
+
+void BrowserWindow::close_current_tab() {
+    if (tabs_.empty()) {
+        return;
+    }
+    
+    if (tabs_.size() == 1) {
+        // Keep at least one tab
+        Tab* tab = tabs_[0].get();
+        tab->set_url("about:blank");
+        ensure_tab_webview_loaded(tab);
+        webkit_web_view_load_uri(tab->get_webview(), "about:blank");
+        tab->set_title("New Tab");
+        refresh_ui();
+        return;
+    }
+    
+    // Remove tab
+    tabs_.erase(tabs_.begin() + active_tab_index_);
+    
+    // Adjust active index
+    if (active_tab_index_ >= tabs_.size()) {
+        active_tab_index_ = tabs_.size() - 1;
+    }
+    
+    refresh_ui();
+    if (!tabs_.empty()) {
+        show_tab(active_tab_index_);
+    }
+}
+
+void BrowserWindow::next_tab() {
+    if (tabs_.empty()) {
+        return;
+    }
+    active_tab_index_ = (active_tab_index_ + 1) % tabs_.size();
+    refresh_ui();
+    show_tab(active_tab_index_);
+}
+
+void BrowserWindow::previous_tab() {
+    if (tabs_.empty()) {
+        return;
+    }
+    active_tab_index_ = (active_tab_index_ == 0) ? tabs_.size() - 1 : active_tab_index_ - 1;
+    refresh_ui();
+    show_tab(active_tab_index_);
+}
+
+void BrowserWindow::focus_address_bar() {
+    gtk_widget_grab_focus(GTK_WIDGET(address_bar_));
+    gtk_editable_select_region(GTK_EDITABLE(address_bar_), 0, -1);
+}
+
+void BrowserWindow::update_tab_bar() {
+    // Clear existing tab buttons
+    GtkWidget* child = gtk_widget_get_first_child(GTK_WIDGET(tab_bar_));
+    while (child) {
+        GtkWidget* next = gtk_widget_get_next_sibling(child);
+        gtk_box_remove(tab_bar_, child);
+        child = next;
+    }
+    
+    // Add tab buttons
+    for (size_t i = 0; i < tabs_.size(); ++i) {
+        Tab* tab = tabs_[i].get();
+        if (!tab) {
+            continue;
+        }
+        
+        GtkButton* button = GTK_BUTTON(gtk_button_new());
+        GtkBox* box = GTK_BOX(gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 4));
+        
+        GtkLabel* label = GTK_LABEL(gtk_label_new(tab->get_title().c_str()));
+        gtk_box_append(box, GTK_WIDGET(label));
+        
+        GtkButton* close_btn = GTK_BUTTON(gtk_button_new_from_icon_name("window-close"));
+        gtk_button_set_has_frame(close_btn, FALSE);
+        g_signal_connect(close_btn, "clicked",
+                         G_CALLBACK(on_tab_close_clicked), this);
+        g_object_set_data(G_OBJECT(close_btn), "tab-index", GINT_TO_POINTER(i));
+        gtk_box_append(box, GTK_WIDGET(close_btn));
+        
+        gtk_button_set_child(button, GTK_WIDGET(box));
+        
+        // Highlight active tab
+        if (i == active_tab_index_) {
+            gtk_widget_add_css_class(GTK_WIDGET(button), "active-tab");
+        }
+        
+        gtk_box_append(tab_bar_, GTK_WIDGET(button));
+    }
+}
+
+void BrowserWindow::update_address_bar() {
+    if (active_tab_index_ < tabs_.size()) {
+        Tab* tab = tabs_[active_tab_index_].get();
+        if (tab) {
+            gtk_entry_set_text(address_bar_, tab->get_url().c_str());
+        }
+    }
+}
+
+void BrowserWindow::update_notebook() {
+    // Handled by show_tab()
+}
+
+void BrowserWindow::refresh_ui() {
+    update_tab_bar();
+    update_address_bar();
+}
+
+void BrowserWindow::ensure_tab_webview_loaded(Tab* tab) {
+    if (!tab || tab->is_loaded()) {
+        return;
+    }
+    
+    tab->create_webview();
+}
+
+void BrowserWindow::show_tab(size_t index) {
+    if (index >= tabs_.size()) {
+        return;
+    }
+    
+    Tab* tab = tabs_[index].get();
+    if (!tab) {
+        return;
+    }
+    
+    ensure_tab_webview_loaded(tab);
+    
+    // Remove all pages from notebook
+    while (gtk_notebook_get_n_pages(notebook_) > 0) {
+        gtk_notebook_remove_page(notebook_, 0);
+    }
+    
+    // Add current tab's container
+    GtkWidget* container = tab->get_container();
+    if (container) {
+        gtk_notebook_append_page(notebook_, container, nullptr);
+    }
+    
+    tab->mark_active();
+    refresh_ui();
+}
+
+void BrowserWindow::on_address_bar_activated(GtkEntry* entry, gpointer user_data) {
+    BrowserWindow* window = static_cast<BrowserWindow*>(user_data);
+    const char* text = gtk_entry_get_text(entry);
+    
+    if (window->tabs_.empty()) {
+        window->new_tab(text);
+        return;
+    }
+    
+    Tab* tab = window->tabs_[window->active_tab_index_].get();
+    if (!tab) {
+        return;
+    }
+    
+    std::string url = text;
+    if (url.find("://") == std::string::npos) {
+        url = "https://" + url;
+    }
+    
+    tab->set_url(url);
+    window->ensure_tab_webview_loaded(tab);
+    WebKitWebView* webview = tab->get_webview();
+    if (webview) {
+        webkit_web_view_load_uri(webview, url.c_str());
+    }
+    window->refresh_ui();
+}
+
+void BrowserWindow::on_tab_close_clicked(GtkButton* button, gpointer user_data) {
+    BrowserWindow* window = static_cast<BrowserWindow*>(user_data);
+    gpointer index_ptr = g_object_get_data(G_OBJECT(button), "tab-index");
+    if (index_ptr) {
+        int index = GPOINTER_TO_INT(index_ptr);
+        if (index >= 0 && index < static_cast<int>(window->tabs_.size())) {
+            window->active_tab_index_ = index;
+            window->close_current_tab();
+        }
+    }
+}
diff --git a/ryxsurf-cpp/src/keyboard_handler.cpp b/ryxsurf-cpp/src/keyboard_handler.cpp
new file mode 100644
index 0000000..1362ca6
--- /dev/null
+++ b/ryxsurf-cpp/src/keyboard_handler.cpp
@@ -0,0 +1,90 @@
+#include "keyboard_handler.h"
+#include "browser_window.h"
+#include <gtk/gtk.h>
+#include <gdk/gdkkeysyms.h>
+
+KeyboardHandler::KeyboardHandler(BrowserWindow* browser_window)
+    : browser_window_(browser_window)
+{
+}
+
+KeyboardHandler::~KeyboardHandler() = default;
+
+void KeyboardHandler::setup_shortcuts(GtkWindow* window) {
+    GtkEventController* controller = gtk_event_controller_key_new();
+    g_signal_connect(controller, "key-pressed",
+                     G_CALLBACK(on_key_pressed), this);
+    GtkWidget* widget = GTK_WIDGET(window);
+    gtk_widget_add_controller(widget, controller);
+    g_object_set_data(G_OBJECT(widget), "keyboard-handler", this);
+}
+
+gboolean KeyboardHandler::on_key_pressed(GtkEventControllerKey* controller,
+                                         guint keyval,
+                                         guint keycode,
+                                         GdkModifierType state,
+                                         gpointer user_data) {
+    KeyboardHandler* handler = static_cast<KeyboardHandler*>(user_data);
+    BrowserWindow* bw = handler->browser_window_;
+    
+    // Check for Ctrl modifier
+    bool ctrl = (state & GDK_CONTROL_MASK) != 0;
+    bool shift = (state & GDK_SHIFT_MASK) != 0;
+    
+    if (!ctrl) {
+        return FALSE;
+    }
+    
+    switch (keyval) {
+        case GDK_KEY_t:
+            // Ctrl+T: New tab
+            bw->new_tab();
+            return TRUE;
+            
+        case GDK_KEY_w:
+            // Ctrl+W: Close current tab
+            bw->close_current_tab();
+            return TRUE;
+            
+        case GDK_KEY_Up:
+            // Ctrl+Up: Previous tab
+            bw->previous_tab();
+            return TRUE;
+            
+        case GDK_KEY_Down:
+            // Ctrl+Down: Next tab
+            bw->next_tab();
+            return TRUE;
+            
+        case GDK_KEY_Left:
+            // Ctrl+Left: Previous session (placeholder)
+            return TRUE;
+            
+        case GDK_KEY_Right:
+            // Ctrl+Right: Next session (placeholder)
+            return TRUE;
+            
+        case GDK_KEY_Tab:
+            // Ctrl+Tab / Ctrl+Shift+Tab: Tab navigation (fallback)
+            if (shift) {
+                bw->previous_tab();
+            } else {
+                bw->next_tab();
+            }
+            return TRUE;
+            
+        case GDK_KEY_l:
+            // Ctrl+L: Focus address bar
+            bw->focus_address_bar();
+            return TRUE;
+            
+        case GDK_KEY_s:
+            if (shift) {
+                // Ctrl+Shift+S: Save session snapshot (placeholder)
+                return TRUE;
+            }
+            break;
+    }
+    
+    return FALSE;
+}
diff --git a/ryxsurf-cpp/src/main.cpp b/ryxsurf-cpp/src/main.cpp
new file mode 100644
index 0000000..5a32229
--- /dev/null
+++ b/ryxsurf-cpp/src/main.cpp
@@ -0,0 +1,22 @@
+#include "browser_window.h"
+#include <gtk/gtk.h>
+#include <webkit/webkit.h>
+
+int main(int argc, char* argv[]) {
+    // Initialize GTK
+    gtk_init(&argc, &argv);
+    
+    // Initialize WebKit with shared secondary process model
+    webkit_web_context_set_process_model(
+        webkit_web_context_get_default(),
+        WEBKIT_PROCESS_MODEL_SHARED_SECONDARY_PROCESS);
+    
+    // Create and show browser window
+    BrowserWindow browser;
+    browser.show();
+    
+    // Run GTK main loop
+    gtk_main();
+    
+    return 0;
+}
diff --git a/ryxsurf-cpp/src/tab.cpp b/ryxsurf-cpp/src/tab.cpp
new file mode 100644
index 0000000..ffbcb5a
--- /dev/null
+++ b/ryxsurf-cpp/src/tab.cpp
@@ -0,0 +1,119 @@
+#include "tab.h"
+#include <webkit/webkit.h>
+#include <gtk/gtk.h>
+
+Tab::Tab(const std::string& url)
+    : url_(url)
+    , title_("New Tab")
+    , webview_(nullptr)
+    , container_(nullptr)
+    , last_active_(std::chrono::steady_clock::now())
+    , is_unloaded_(false)
+{
+}
+
+Tab::~Tab() {
+    destroy_webview();
+}
+
+WebKitWebView* Tab::get_webview() {
+    if (!webview_ && !is_unloaded_) {
+        create_webview();
+    }
+    return webview_;
+}
+
+GtkWidget* Tab::get_container() {
+    if (!container_ && !is_unloaded_) {
+        create_webview();
+    }
+    return container_;
+}
+
+void Tab::create_webview() {
+    if (webview_) {
+        return;
+    }
+    
+    // Create WebKit settings for minimal resource usage
+    WebKitSettings* settings = webkit_settings_new();
+    webkit_settings_set_enable_plugins(settings, FALSE);
+    webkit_settings_set_enable_java(settings, FALSE);
+    webkit_settings_set_enable_media_stream(settings, FALSE);
+    webkit_settings_set_enable_mediasource(settings, FALSE);
+    webkit_settings_set_hardware_acceleration_policy(
+        settings, WEBKIT_HARDWARE_ACCELERATION_POLICY_ALWAYS);
+    
+    // Create WebView
+    webview_ = WEBKIT_WEB_VIEW(webkit_web_view_new_with_settings(settings));
+    g_object_unref(settings);
+    
+    // Create container
+    container_ = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
+    gtk_box_append(GTK_BOX(container_), GTK_WIDGET(webview_));
+    
+    // Load URL if set
+    if (!url_.empty() && url_ != "about:blank") {
+        webkit_web_view_load_uri(webview_, url_.c_str());
+    }
+    
+    // Connect title changed signal
+    g_signal_connect(webview_, "notify::title",
+                     G_CALLBACK(+[](WebKitWebView* view, GParamSpec*, gpointer data) {
+                         Tab* tab = static_cast<Tab*>(data);
+                         char* title = webkit_web_view_get_title(view);
+                         if (title) {
+                             tab->set_title(title);
+                             g_free(title);
+                         }
+                     }), this);
+    
+    mark_active();
+    is_unloaded_ = false;
+}
+
+void Tab::destroy_webview() {
+    if (webview_) {
+        if (container_) {
+            GtkWidget* parent = gtk_widget_get_parent(container_);
+            if (parent) {
+                gtk_box_remove(GTK_BOX(parent), container_);
+            }
+            gtk_widget_unparent(container_);
+        }
+        g_object_unref(webview_);
+        webview_ = nullptr;
+        container_ = nullptr;
+    }
+}
+
+void Tab::unload() {
+    if (is_unloaded_ || !webview_) {
+        return;
+    }
+    
+    // Save URL before unloading
+    char* uri = webkit_web_view_get_uri(webview_);
+    if (uri) {
+        url_ = uri;
+        g_free(uri);
+    }
+    
+    destroy_webview();
+    is_unloaded_ = true;
+}
+
+void Tab::restore() {
+    if (!is_unloaded_) {
+        return;
+    }
+    
+    create_webview();
+    if (!url_.empty() && url_ != "about:blank") {
+        webkit_web_view_load_uri(webview_, url_.c_str());
+    }
+}
+
+void Tab::mark_active() {
+    last_active_ = std::chrono::steady_clock::now();
+}
diff --git a/ryxsurf-cpp/tests/test_tab.cpp b/ryxsurf-cpp/tests/test_tab.cpp
new file mode 100644
index 0000000..fe97a06
--- /dev/null
+++ b/ryxsurf-cpp/tests/test_tab.cpp
@@ -0,0 +1,48 @@
+#define CATCH_CONFIG_MAIN
+#include <catch2/catch.hpp>
+#include "../include/tab.h"
+#include <chrono>
+#include <thread>
+
+TEST_CASE("Tab creation", "[tab]") {
+    Tab tab("https://example.com");
+    
+    REQUIRE(tab.get_url() == "https://example.com");
+    REQUIRE(tab.get_title() == "New Tab");
+    REQUIRE_FALSE(tab.is_loaded());
+    REQUIRE_FALSE(tab.is_unloaded());
+}
+
+TEST_CASE("Tab lazy loading", "[tab]") {
+    Tab tab("https://example.com");
+    
+    REQUIRE_FALSE(tab.is_loaded());
+    
+    // WebView should be created on first access
+    // Note: This requires GTK/WebKit initialization, so we test metadata only
+    REQUIRE(tab.get_url() == "https://example.com");
+}
+
+TEST_CASE("Tab activity tracking", "[tab]") {
+    Tab tab;
+    
+    auto time1 = tab.get_last_active();
+    std::this_thread::sleep_for(std::chrono::milliseconds(10));
+    tab.mark_active();
+    auto time2 = tab.get_last_active();
+    
+    REQUIRE(time2 > time1);
+}
+
+TEST_CASE("Tab unload/restore", "[tab]") {
+    Tab tab("https://example.com");
+    
+    REQUIRE_FALSE(tab.is_unloaded());
+    
+    // Unload should mark as unloaded
+    tab.unload();
+    REQUIRE(tab.is_unloaded());
+    
+    // URL should be preserved
+    REQUIRE(tab.get_url() == "https://example.com");
+}
-- 
2.52.0

